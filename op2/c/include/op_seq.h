//
//auto-generated by op_seq_gen.m on 18-May-2012 09:52:35
//

//
// header for sequential and MPI+sequentional execution
//

#include "op_lib_core.h"

char blank_args[512]; // scratch space to use for blank args

inline void op_arg_set(int n, op_arg arg, char **p_arg, int halo){
  *p_arg = arg.data;

  if (arg.argtype==OP_ARG_GBL) {
    if (halo && (arg.acc != OP_READ)) *p_arg = blank_args;
  }
  else {
    if (arg.map==NULL)         // identity mapping
      *p_arg += arg.size*n;
    else                       // standard pointers
      *p_arg += arg.size*arg.map->map[arg.idx+n*arg.map->dim];
  }
}

inline void op_args_check(op_set set, int nargs, op_arg *args,
                                      int *ninds, const char *name) {
  for (int n=0; n<nargs; n++)
    op_arg_check(set,n,args[n],ninds,name);
}


//
// op_par_loop routine for 1 arguments
//

template < class T0 >
void op_par_loop(void (*kernel)( T0* ),
    char const * name, op_set set,
    op_arg arg0 ) {

  char  *p_a[1] = {0};
  op_arg args[1] = { arg0 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,1,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 1,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(1,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(1, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 1, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 2 arguments
//

template < class T0, class T1 >
void op_par_loop(void (*kernel)( T0*, T1* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1 ) {

  char  *p_a[2] = {0,0};
  op_arg args[2] = { arg0, arg1 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,2,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 2,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(2,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(2, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 2, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 3 arguments
//

template < class T0, class T1, class T2 >
void op_par_loop(void (*kernel)( T0*, T1*, T2* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1, op_arg arg2 ) {

  char  *p_a[3] = {0,0,0};
  op_arg args[3] = { arg0, arg1, arg2 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,3,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 3,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(3,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);
    op_arg_set(n, arg2, &p_a[2], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1],  (T2 *)p_a[2] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(3, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  op_mpi_reduce(&arg2,(T2 *)p_a[2]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 3, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 4 arguments
//

template < class T0, class T1, class T2, class T3 >
void op_par_loop(void (*kernel)( T0*, T1*, T2*, T3* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1, op_arg arg2, op_arg arg3 ) {

  char  *p_a[4] = {0,0,0,0};
  op_arg args[4] = { arg0, arg1, arg2, arg3 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,4,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 4,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(4,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);
    op_arg_set(n, arg2, &p_a[2], halo);
    op_arg_set(n, arg3, &p_a[3], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1],  (T2 *)p_a[2],  (T3 *)p_a[3] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(4, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  op_mpi_reduce(&arg2,(T2 *)p_a[2]);
  op_mpi_reduce(&arg3,(T3 *)p_a[3]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 4, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 5 arguments
//

template < class T0, class T1, class T2, class T3,
           class T4 >
void op_par_loop(void (*kernel)( T0*, T1*, T2*, T3*,
                                 T4* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1, op_arg arg2, op_arg arg3,
    op_arg arg4 ) {

  char  *p_a[5] = {0,0,0,0,0};
  op_arg args[5] = { arg0, arg1, arg2, arg3,
                      arg4 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,5,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 5,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(5,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);
    op_arg_set(n, arg2, &p_a[2], halo);
    op_arg_set(n, arg3, &p_a[3], halo);
    op_arg_set(n, arg4, &p_a[4], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1],  (T2 *)p_a[2],  (T3 *)p_a[3],
            (T4 *)p_a[4] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(5, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  op_mpi_reduce(&arg2,(T2 *)p_a[2]);
  op_mpi_reduce(&arg3,(T3 *)p_a[3]);
  op_mpi_reduce(&arg4,(T4 *)p_a[4]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 5, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 6 arguments
//

template < class T0, class T1, class T2, class T3,
           class T4, class T5 >
void op_par_loop(void (*kernel)( T0*, T1*, T2*, T3*,
                                 T4*, T5* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1, op_arg arg2, op_arg arg3,
    op_arg arg4, op_arg arg5 ) {

  char  *p_a[6] = {0,0,0,0,0,0};
  op_arg args[6] = { arg0, arg1, arg2, arg3,
                      arg4, arg5 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,6,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 6,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(6,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);
    op_arg_set(n, arg2, &p_a[2], halo);
    op_arg_set(n, arg3, &p_a[3], halo);
    op_arg_set(n, arg4, &p_a[4], halo);
    op_arg_set(n, arg5, &p_a[5], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1],  (T2 *)p_a[2],  (T3 *)p_a[3],
            (T4 *)p_a[4],  (T5 *)p_a[5] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(6, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  op_mpi_reduce(&arg2,(T2 *)p_a[2]);
  op_mpi_reduce(&arg3,(T3 *)p_a[3]);
  op_mpi_reduce(&arg4,(T4 *)p_a[4]);
  op_mpi_reduce(&arg5,(T5 *)p_a[5]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 6, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 7 arguments
//

template < class T0, class T1, class T2, class T3,
           class T4, class T5, class T6 >
void op_par_loop(void (*kernel)( T0*, T1*, T2*, T3*,
                                 T4*, T5*, T6* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1, op_arg arg2, op_arg arg3,
    op_arg arg4, op_arg arg5, op_arg arg6 ) {

  char  *p_a[7] = {0,0,0,0,0,0,0};
  op_arg args[7] = { arg0, arg1, arg2, arg3,
                      arg4, arg5, arg6 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,7,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 7,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(7,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);
    op_arg_set(n, arg2, &p_a[2], halo);
    op_arg_set(n, arg3, &p_a[3], halo);
    op_arg_set(n, arg4, &p_a[4], halo);
    op_arg_set(n, arg5, &p_a[5], halo);
    op_arg_set(n, arg6, &p_a[6], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1],  (T2 *)p_a[2],  (T3 *)p_a[3],
            (T4 *)p_a[4],  (T5 *)p_a[5],  (T6 *)p_a[6] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(7, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  op_mpi_reduce(&arg2,(T2 *)p_a[2]);
  op_mpi_reduce(&arg3,(T3 *)p_a[3]);
  op_mpi_reduce(&arg4,(T4 *)p_a[4]);
  op_mpi_reduce(&arg5,(T5 *)p_a[5]);
  op_mpi_reduce(&arg6,(T6 *)p_a[6]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 7, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 8 arguments
//

template < class T0, class T1, class T2, class T3,
           class T4, class T5, class T6, class T7 >
void op_par_loop(void (*kernel)( T0*, T1*, T2*, T3*,
                                 T4*, T5*, T6*, T7* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1, op_arg arg2, op_arg arg3,
    op_arg arg4, op_arg arg5, op_arg arg6, op_arg arg7 ) {

  char  *p_a[8] = {0,0,0,0,0,0,0,0};
  op_arg args[8] = { arg0, arg1, arg2, arg3,
                      arg4, arg5, arg6, arg7 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,8,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 8,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(8,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);
    op_arg_set(n, arg2, &p_a[2], halo);
    op_arg_set(n, arg3, &p_a[3], halo);
    op_arg_set(n, arg4, &p_a[4], halo);
    op_arg_set(n, arg5, &p_a[5], halo);
    op_arg_set(n, arg6, &p_a[6], halo);
    op_arg_set(n, arg7, &p_a[7], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1],  (T2 *)p_a[2],  (T3 *)p_a[3],
            (T4 *)p_a[4],  (T5 *)p_a[5],  (T6 *)p_a[6],  (T7 *)p_a[7] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(8, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  op_mpi_reduce(&arg2,(T2 *)p_a[2]);
  op_mpi_reduce(&arg3,(T3 *)p_a[3]);
  op_mpi_reduce(&arg4,(T4 *)p_a[4]);
  op_mpi_reduce(&arg5,(T5 *)p_a[5]);
  op_mpi_reduce(&arg6,(T6 *)p_a[6]);
  op_mpi_reduce(&arg7,(T7 *)p_a[7]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 8, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 9 arguments
//

template < class T0, class T1, class T2, class T3,
           class T4, class T5, class T6, class T7,
           class T8 >
void op_par_loop(void (*kernel)( T0*, T1*, T2*, T3*,
                                 T4*, T5*, T6*, T7*,
                                 T8* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1, op_arg arg2, op_arg arg3,
    op_arg arg4, op_arg arg5, op_arg arg6, op_arg arg7,
    op_arg arg8 ) {

  char  *p_a[9] = {0,0,0,0,0,0,0,0,0};
  op_arg args[9] = { arg0, arg1, arg2, arg3,
                      arg4, arg5, arg6, arg7,
                      arg8 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,9,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 9,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(9,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);
    op_arg_set(n, arg2, &p_a[2], halo);
    op_arg_set(n, arg3, &p_a[3], halo);
    op_arg_set(n, arg4, &p_a[4], halo);
    op_arg_set(n, arg5, &p_a[5], halo);
    op_arg_set(n, arg6, &p_a[6], halo);
    op_arg_set(n, arg7, &p_a[7], halo);
    op_arg_set(n, arg8, &p_a[8], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1],  (T2 *)p_a[2],  (T3 *)p_a[3],
            (T4 *)p_a[4],  (T5 *)p_a[5],  (T6 *)p_a[6],  (T7 *)p_a[7],
            (T8 *)p_a[8] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(9, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  op_mpi_reduce(&arg2,(T2 *)p_a[2]);
  op_mpi_reduce(&arg3,(T3 *)p_a[3]);
  op_mpi_reduce(&arg4,(T4 *)p_a[4]);
  op_mpi_reduce(&arg5,(T5 *)p_a[5]);
  op_mpi_reduce(&arg6,(T6 *)p_a[6]);
  op_mpi_reduce(&arg7,(T7 *)p_a[7]);
  op_mpi_reduce(&arg8,(T8 *)p_a[8]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 9, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}


//
// op_par_loop routine for 10 arguments
//

template < class T0, class T1, class T2, class T3,
           class T4, class T5, class T6, class T7,
           class T8, class T9 >
void op_par_loop(void (*kernel)( T0*, T1*, T2*, T3*,
                                 T4*, T5*, T6*, T7*,
                                 T8*, T9* ),
    char const * name, op_set set,
    op_arg arg0, op_arg arg1, op_arg arg2, op_arg arg3,
    op_arg arg4, op_arg arg5, op_arg arg6, op_arg arg7,
    op_arg arg8, op_arg arg9 ) {

  char  *p_a[10] = {0,0,0,0,0,0,0,0,0,0};
  op_arg args[10] = { arg0, arg1, arg2, arg3,
                      arg4, arg5, arg6, arg7,
                      arg8, arg9 };

  // consistency checks

  int ninds = 0;

  if (OP_diags>0) op_args_check(set,10,args,&ninds,name);

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s\n",name);
    else
      printf(" kernel routine with indirection: %s\n",name);
  }

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers_core(&cpu_t1, &wall_t1);

  // MPI halo exchange and dirty bit setting, if needed

  int n_upper = op_mpi_halo_exchanges(set, 10,args);

  // loop over set elements

  int halo = 0;

  for (int n=0; n<n_upper; n++) {
    if (n==set->core_size) op_mpi_wait_all(10,args);
    if (n==set->size) halo = 1;

    op_arg_set(n, arg0, &p_a[0], halo);
    op_arg_set(n, arg1, &p_a[1], halo);
    op_arg_set(n, arg2, &p_a[2], halo);
    op_arg_set(n, arg3, &p_a[3], halo);
    op_arg_set(n, arg4, &p_a[4], halo);
    op_arg_set(n, arg5, &p_a[5], halo);
    op_arg_set(n, arg6, &p_a[6], halo);
    op_arg_set(n, arg7, &p_a[7], halo);
    op_arg_set(n, arg8, &p_a[8], halo);
    op_arg_set(n, arg9, &p_a[9], halo);

    // call kernel function, passing in pointers to data

    kernel( (T0 *)p_a[0],  (T1 *)p_a[1],  (T2 *)p_a[2],  (T3 *)p_a[3],
            (T4 *)p_a[4],  (T5 *)p_a[5],  (T6 *)p_a[6],  (T7 *)p_a[7],
            (T8 *)p_a[8],  (T9 *)p_a[9] );
  }

  //set dirty bit on datasets touched
  op_mpi_set_dirtybit(10, args);

  // global reduction for MPI execution, if needed

  op_mpi_reduce(&arg0,(T0 *)p_a[0]);
  op_mpi_reduce(&arg1,(T1 *)p_a[1]);
  op_mpi_reduce(&arg2,(T2 *)p_a[2]);
  op_mpi_reduce(&arg3,(T3 *)p_a[3]);
  op_mpi_reduce(&arg4,(T4 *)p_a[4]);
  op_mpi_reduce(&arg5,(T5 *)p_a[5]);
  op_mpi_reduce(&arg6,(T6 *)p_a[6]);
  op_mpi_reduce(&arg7,(T7 *)p_a[7]);
  op_mpi_reduce(&arg8,(T8 *)p_a[8]);
  op_mpi_reduce(&arg9,(T9 *)p_a[9]);
  // update timer record
  op_timers_core(&cpu_t2, &wall_t2);
#ifdef COMM_PERF
  int k_i = op_mpi_perf_time(name, wall_t2 - wall_t1);
  op_mpi_perf_comms(k_i, 10, args);
#else
  op_mpi_perf_time(name, wall_t2 - wall_t1);
#endif
}

