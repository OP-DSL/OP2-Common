{%- macro map_idx(arg) -%}
    {%- if arg is runtime_map_idx %}
arg{{arg.id}}_idx
    {%- else -%}
{{arg.map_idx}}
    {%- endif -%}
{%- endmacro -%}

{%- macro arg_to_pointer(arg) -%}
    {%- if arg is idx and arg is indirect -%}
map{{arg.map_id}}({{arg.map_idx}}, n) + 1
    {%- elif arg is idx -%}
n
    {%- elif arg is gbl and arg is not read and lh is indirect -%}
gbl{{arg.id}}_temp{{"(1)" if arg.dim == 1 }}
    {%- elif arg is gbl -%}
gbl{{arg.id}}{{"(1)" if arg.dim == 1 }}
    {%- elif arg is direct -%}
dat{{arg.dat_id}}({{"1" if lh.dat(arg).dim == 1 else ":"}}, n)
    {%- else -%}
dat{{arg.dat_id}}({{"1" if lh.dat(arg).dim == 1 else ":"}}, map{{arg.map_id}}({{map_idx(arg)}}, n) + 1)
    {%- endif -%}
{%- endmacro -%}

{%- macro type_c(arg) -%}
    {%- if arg.typ is instance(OP.Int) -%}
        int
    {%- elif arg.typ is instance(OP.Bool) -%}
        bool
    {%- elif arg.typ.size == 32 -%}
        float
    {%- else -%}
        double
    {%- endif -%}
{%- endmacro -%}

{%- macro dat_dim(dat) -%}
    {%- if dat.dim is not none -%}
{{dat.dim}}
    {%- else -%}
arg{{dat.arg_id}}%dim
    {%- endif -%}
{%- endmacro -%}

{%- macro arg_dim(arg) -%}
    {%- if arg is gbl and arg.dim is not none -%}
{{arg.dim}}
    {%- elif arg is dat and lh.dat(arg).dim is not none -%}
{{lh.dat(arg).dim}}
    {%- else -%}
arg{{arg.id}}%dim
    {%- endif -%}
{%- endmacro -%}

module op2_k{{kernel_idx}}

    use iso_c_binding

    use op2_fortran_declarations
    use op2_fortran_rt_support

    use {{"op2_consts" if lang.user_consts_module is none else lang.user_consts_module}}

    implicit none

    private
    public :: op2_k{{kernel_idx}}_{{lh.kernel}}

contains

{{kernel_func}}

subroutine {{lh.kernel}}_wrapper( &
{% for dat in lh.dats %}
    dat{{dat.id}}, &
{% endfor %}
{% for map in lh.maps %}
    map{{map.id}}, &
{% endfor %}
{% for arg in lh.args|runtime_map_idx %}
    arg{{arg.id}}_idx, &
{% endfor %}
{% for arg in lh.args|gbl %}
    gbl{{arg.id}}, &
{% endfor %}
    n_exec, &
    set, &
    args &
)
    implicit none

    ! parameters
{% for dat in lh.dats %}
    {{dat.typ}}, dimension(:, :) :: dat{{dat.id}}{{"\n" if loop.last}}
{% endfor %}
{% for map in lh.maps %}
    integer(4), dimension(:, :) :: map{{map.id}}{{"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|runtime_map_idx %}
    integer(4) :: arg{{arg.id}}_idx{{"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|gbl %}
    {{arg.typ}}, dimension(:) :: gbl{{arg.id}}{{"\n" if loop.last}}
{% endfor %}
    integer(4) :: n_exec
    type(op_set) :: set
    type(op_arg), dimension({{lh.args|length}}) :: args

    ! locals
{% for arg in lh.args|gbl|reject("read") if lh is indirect %}
    {{arg.typ}}, dimension(size(gbl{{arg.id}})) :: gbl{{arg.id}}_temp{{"\n" if loop.last}}
{% endfor %}
    integer(4) :: n

{% for arg in lh.args|gbl|reduction if lh is indirect %}
    gbl{{arg.id}}_temp = gbl{{arg.id}}{{"\n" if loop.last}}
{% endfor %}
    do n = 1, n_exec
    {% if lh is indirect %}
        if (n == set%setptr%core_size + 1) then
            call op_mpi_wait_all(size(args), args)
        end if

    {% endif %}
    {% if lh is indirect and lh.args|gbl|reject("read")|list|length > 0 %}
        if (n == set%setptr%size + 1) then
        {% for arg in lh.args|gbl|reject("read") %}
            gbl{{arg.id}} = gbl{{arg.id}}_temp
        {% endfor %}
        end if

    {% endif %}
        call {{lh.kernel}}( &
{% for arg in lh.args %}
            {{arg_to_pointer(arg)}}{{"," if not loop.last}} &
{% endfor %}
        )
    end do
{% if lh is indirect and lh.args|gbl|reject("read")|list|length > 0 %}

    if (n_exec <= set%setptr%size) then
    {% for arg in lh.args|gbl|reject("read") %}
        gbl{{arg.id}} = gbl{{arg.id}}_temp
    {% endfor %}
    end if
{% endif %}
end subroutine

subroutine op2_k{{kernel_idx}}_{{lh.kernel}}( &
    name, &
    set, &
{% for arg in lh.args %}
    arg{{arg.id}}{{"," if not loop.last}} &
{% endfor %}
)
    implicit none

    ! parameters
    character(kind=c_char, len=*) :: name
    type(op_set) :: set

{% for arg in lh.args %}
    type(op_arg) :: arg{{arg.id}}
{% endfor %}

    ! locals
    type(op_arg), dimension({{lh.args|length}}) :: args

    integer(4) :: n_exec

{% for dat in lh.dats %}
    {{dat.typ}}, pointer, dimension(:, :) :: dat{{dat.id}}{{"\n" if loop.last}}
{% endfor %}
{% for map in lh.maps %}
    integer(4), pointer, dimension(:, :) :: map{{map.id}}{{"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|gbl %}
    {{arg.typ}}, pointer, dimension(:) :: gbl{{arg.id}}{{"\n" if loop.last}}
{% endfor %}
    real(8) :: start_time, end_time
    real(4) :: transfer

{% for arg in lh.args %}
    args({{arg.id + 1}}) = arg{{arg.id}}
{% endfor %}

    call op_timers_core(start_time)
    n_exec = op_mpi_halo_exchanges(set%setcptr, size(args), args)

{% for dat in lh.dats %}
    call c_f_pointer(arg{{dat.arg_id}}%data, dat{{dat.id}}, (/{{dat_dim(dat)}}, getsetsizefromoparg(arg{{dat.arg_id}})/))
        {{-"\n" if loop.last}}
{% endfor %}
{% for map in lh.maps %}
    call c_f_pointer(arg{{map.arg_id}}%map_data, map{{map.id}}, (/getmapdimfromoparg(arg{{map.arg_id}}), set%setptr%size/))
        {{-"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|gbl %}
    call c_f_pointer(arg{{arg.id}}%data, gbl{{arg.id}}, (/{{arg_dim(arg)}}/)){{"\n" if loop.last}}
{% endfor %}
    call {{lh.kernel}}_wrapper( &
{% for dat in lh.dats %}
        dat{{dat.id}}, &
{% endfor %}
{% for map in lh.maps %}
        map{{map.id}}, &
{% endfor %}
{% for arg in lh.args|runtime_map_idx %}
        arg{{arg.id}}%idx + 1, &
{% endfor %}
{% for arg in lh.args|gbl %}
        gbl{{arg.id}}, &
{% endfor %}
        n_exec, &
        set, &
        args &
    )

    if ((n_exec == 0) .or. (n_exec == set%setptr%core_size)) then
        call op_mpi_wait_all(size(args), args)
    end if

{% for arg in lh.args|gbl|reduction %}
    call op_mpi_reduce_{{arg.typ.__repr__()}}(arg{{arg.id}}, arg{{arg.id}}%data){{"\n" if loop.last}}
{% endfor %}
    call op_mpi_set_dirtybit(size(args), args)
    call op_timers_core(end_time)

    ! todo: review kernel transfer calculation
    transfer = 0.0

    call setkerneltime({{kernel_idx}}, name // c_null_char, end_time - start_time, transfer, 0.0, 1)
end subroutine

end module
