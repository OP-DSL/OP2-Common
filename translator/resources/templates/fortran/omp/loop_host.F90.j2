{# Template imports #}
{% from 'fortran/macros.j2' import op_opt %}
{% from 'macros.j2' import comma %}

MODULE {{ parloop.name|upper }}_MODULE

  USE OP2_FORTRAN_DECLARATIONS
  USE OP2_FORTRAN_RT_SUPPORT
  USE ISO_C_BINDING
  USE OP2_CONSTANTS

#ifdef _OPENMP
  USE OMP_LIB
#endif

  CONTAINS

  ! Include kernel function
#include "{{ parloop.kernel }}.inc"


  ! Wrapper for kernel function
  SUBROUTINE {{ parloop.name }}_wrap ( &
    {# Globals #}
    {% for arg in parloop.globals  %}
    & gblDat_{{ arg.var }}, &
    {% endfor %}
    {# Directs #}
    {% for arg in parloop.directs %}
    & dirDat_{{ arg.var }}, &
    {% endfor %}
    {# Indirects #}
    {% for arg in parloop.indirectVars %}
    & indDat_{{ arg.var }}, &
    {% endfor %}
    {# Maps #}
    {% for arg in parloop.indirectMaps  %}
    & map_{{ arg.map }}, &
    & mapDim_{{ arg.map }}, &
    {% endfor %}
    {#  #}
    & bottom, &
    & top &
    & )

    IMPLICIT NONE

    {% for arg in parloop.indirectVars %}
    {% if arg is without_dim %}
    {% set dim %}indDatDim_{{ arg.var }}{% endset %}
    INTEGER(kind=4) {{ dim }}
    {% else %}
    {% set dim = arg.dim %}
    {% endif %}
    {{ arg.typ }} indDat_{{ arg.var }}({{ dim }},*)
    {% endfor %}
    {#- -#}
    {% for arg in parloop.directs %}
    {% if arg is without_dim %}
    {% set dim %}dirDatDim_{{ arg.var }}{% endset %}
    INTEGER(kind=4) {{ dim }}
    {% else %}
    {% set dim = arg.dim %}
    {% endif %}
    {{ arg.typ }} dirDat_{{ arg.var }}({{ dim }},*)
    {% endfor %}
    {#- -#}
    {% for arg in parloop.globals %}
    {% if arg is without_dim %}
    {% set dim %}gblDatDim_{{ arg.var }}{% endset %}
    INTEGER(kind=4) {{ dim }}
    {% else %}
    {% set dim = arg.dim %}
    {% endif %}
    {{ arg.typ }} gblDat_{{ arg.var }}({{ dim }})
    {% endfor %}

    {% for arg in parloop.indirectMaps %}
    INTEGER(kind=4) map_{{ arg.map }}(*)
    INTEGER(kind=4) mapDim_{{ arg.map }}
    {% endfor %}
    {% for arg in parloop.indirectIdxs %}
    INTEGER(kind=4) mapIdx_{{ arg.map }}_{{ arg.idx-1 }}
    {% endfor %}
    INTEGER(kind=4) bottom,top,i

    DO i = bottom, top - 1, 1
      {% for arg in parloop.indirectIdxs %}
      mapIdx_{{ arg.map }}_{{ arg.idx-1 }} = map_{{ arg.map }}(1 + i * mapDim_{{ arg.map }} + {{ arg.idx-1 }})+1
      {% endfor %}

      ! Kernel call
      CALL {{ parloop.kernel }}( &
      {%  for arg in parloop.args %}
      {%    if arg is indirect %}
        & indDat_{{ arg.var }}(1,mapIdx_{{ arg.map }}_{{ arg.idx-1 }}){{ comma(loop) }} &
      {%    elif arg is direct %}
        & dirDat_{{ arg.var }}(1,i+1){{ comma(loop) }} &
      {%    elif arg is global %}
        & gblDat_{{ arg.var }}(1){{ comma(loop) }} &
      {%    endif %}
      {%  endfor %}
      & )

    END DO

  END SUBROUTINE

  ! Host function for kernel
  SUBROUTINE {{ parloop.name }}_host ( &
    & kernel, &
    & set, &
    {% for arg in parloop.args %}
    & opArg{{ arg.i+1 }}{{ comma(loop) }} &
    {% endfor %}
    & )

    IMPLICIT NONE
    character(kind=c_char,len=*), INTENT(IN) :: kernel
    type ( op_set ) , INTENT(IN) :: set

    {% for arg in parloop.args %}
    type ( op_arg ) , INTENT(IN) :: opArg{{ arg.i+1 }}
    {% endfor %}

    type ( op_arg ) , DIMENSION({{ parloop.args | length }}) :: opArgArray
    INTEGER(kind=4) :: numberOfOpDats
    INTEGER(kind=4) :: n_upper
    type ( op_set_core ) , POINTER :: opSetCore

    {# TODO: Opts #}

    {# Indirect dats #}
    {% for arg in parloop.indirectVars %}
    {{ arg.typ }}, POINTER, DIMENSION(:) :: indDat_{{ arg.var }}
    INTEGER(kind=4) :: indDatCard_{{ arg.var }}
    {% endfor %}
    {# Direct dats #}
    {% for arg in parloop.directs %}
    {{ arg.typ }}, POINTER, DIMENSION(:) :: dirDat_{{ arg.var }}
    INTEGER(kind=4) :: dirDatCard_{{ arg.var }}
    {% endfor %}
    {# Global dats #}
    {% for arg in parloop.globals %}
    {{ arg.typ }}, POINTER, DIMENSION(:) :: gblDat_{{ arg.var }}
    {{ arg.typ }}, DIMENSION(:), ALLOCATABLE :: reductionArrayHost{{ arg.var }}
    {% endfor %}
    {# Maps #}
    {% for arg in parloop.indirectMaps  %}
    INTEGER(kind=4), POINTER, DIMENSION(:) :: map_{{ arg.map }}
    INTEGER(kind=4) :: mapDim_{{ arg.map }}
    {% endfor %}

    {# Timer vars #}
    INTEGER(kind=4), DIMENSION(1:8) :: timeArrayStart
    INTEGER(kind=4), DIMENSION(1:8) :: timeArrayEnd
    REAL(kind=8) :: startTime
    REAL(kind=8) :: endTime
    INTEGER(kind=4) :: returnSetKernelTiming

    {# OMP vars #}
    INTEGER(kind=4) :: threadID
    INTEGER(kind=4) :: numberOfThreads
    INTEGER(kind=4) :: sliceStart
    INTEGER(kind=4) :: sliceEnd

    {# Plan vars #}
    {# Indirection #}
    {% if parloop.indirection %}
    type ( c_ptr )  :: planRet_{{ parloop.name }}
    type ( op_plan ) , POINTER :: actualPlan_{{ parloop.name }}
    INTEGER(kind=4), POINTER, DIMENSION(:) :: ncolblk_{{ parloop.name }}
    INTEGER(kind=4), POINTER, DIMENSION(:) :: blkmap_{{ parloop.name }}
    INTEGER(kind=4), POINTER, DIMENSION(:) :: nelems_{{ parloop.name }}
    INTEGER(kind=4), POINTER, DIMENSION(:) :: offset_{{ parloop.name }}
    INTEGER(kind=4), DIMENSION(1:{{ parloop.args | length }}) :: indirectionDescriptorArray
    INTEGER(kind=4) :: numberOfIndirectOpDats
    INTEGER(kind=4) :: blockOffset
    INTEGER(kind=4) :: nblocks
    INTEGER(kind=4) :: partitionSize
    INTEGER(kind=4) :: blockID
    INTEGER(kind=4) :: nelem
    INTEGER(kind=4) :: offset_b
    {% else %}
    REAL(kind=4) :: dataTransfer
    {% endif %}
    INTEGER(kind=4) :: i1,i2

    numberOfOpDats = {{ parloop.args | length }}

    {% for arg in parloop.args %}
    opArgArray({{ arg.i+1 }}) = opArg{{ arg.i+1 }}
    {% endfor %}

    returnSetKernelTiming = setKernelTime( &
    & {{ id }}, kernel//C_NULL_CHAR, &
    & 0.0_8, 0.00000_4,0.00000_4, 0 &
    & )
    CALL op_timers_core(startTime)

    n_upper = op_mpi_halo_exchanges(set%setCPtr,numberOfOpDats,opArgArray)

    opSetCore => set%setPtr

    {# Indirection #}
    {% if parloop.indirection %}
#ifdef OP_PART_SIZE_1
  partitionSize = OP_PART_SIZE_1
#else
  partitionSize = 0
#endif
    {% endif %}

#ifdef _OPENMP
  numberOfThreads = omp_get_max_threads()
#else
  numberOfThreads = 1
#endif

    {# Indirection - plan setup #}
    {% if parloop.indirection %}
    {% for i in parloop.indirectionDescriptor %}
    indirectionDescriptorArray({{ loop.index }}) = {{ i }}
    {% endfor %}
    numberOfIndirectOpDats = {{ parloop.indirectVars | length }}

    planRet_{{ parloop.name }} = FortranPlanCaller( &
    & kernel//C_NULL_CHAR, &
    & set%setCPtr, &
    & partitionSize, &
    & numberOfOpDats, &
    & opArgArray, &
    & numberOfIndirectOpDats, &
    & indirectionDescriptorArray,{{id}})

    CALL c_f_pointer(planRet_{{ parloop.name }},actualPlan_{{ parloop.name }})
    CALL c_f_pointer(actualPlan_{{ parloop.name }}%ncolblk,ncolblk_{{ parloop.name }},(/actualPlan_{{ parloop.name }}%ncolors_core/))
    CALL c_f_pointer(actualPlan_{{ parloop.name }}%blkmap,blkmap_{{ parloop.name }},(/actualPlan_{{ parloop.name }}%nblocks/))
    CALL c_f_pointer(actualPlan_{{ parloop.name }}%offset,offset_{{ parloop.name }},(/actualPlan_{{ parloop.name }}%nblocks/))
    CALL c_f_pointer(actualPlan_{{ parloop.name }}%nelems,nelems_{{ parloop.name }},(/actualPlan_{{ parloop.name }}%nblocks/))
    {% endif %}

    opSetCore => set%setPtr

    {# Setup for c to f pointers for maps/dats/globals #}
    {# Directs #}
    {% for arg in parloop.directs %}
    dirDatCard_{{ arg.var }} = opArg{{ arg.i+1 }}%dim * getSetSizeFromOpArg(opArg{{ arg.i+1 }})
    {% endfor %}
    {# Indirects #}
    {% for arg in parloop.indirectVars %}
    indDatCard_{{ arg.var }} = opArg{{ arg.i+1 }}%dim * getSetSizeFromOpArg(opArg{{ arg.i+1 }})
    {% endfor %}
    {# Maps #}
    {% for arg in parloop.indirectMaps  %}
    mapDim_{{ arg.map }} = getMapDimFromOpArg(opArg{{ arg.i+1 }})
    {% endfor %}
    {# Global #}
    {% for arg in parloop.globals %}
    CALL c_f_pointer(opArg{{ arg.i+1 }}%data, gblDat_{{ arg.var }}, (/opArg{{ arg.i+1 }}%dim/))
    {% endfor %}
    {# Directs #}
    {% for arg in parloop.directs %}
    CALL c_f_pointer(opArg{{ arg.i+1 }}%data, dirDat_{{ arg.var }}, (/dirDatCard_{{ arg.var }}/))
    {% endfor %}
    {# Indirects #}
    {% for arg in parloop.indirectVars %}
    CALL c_f_pointer(opArg{{ arg.i+1 }}%data, indDat_{{ arg.var }}, (/indDatCard_{{ arg.var }}/))
    CALL c_f_pointer(opArg{{ arg.i+1 }}%map_data, map_{{ arg.map }}, (/opSetCore%size*mapDim_{{ arg.map }}/))
    {% endfor %}

    {# Setup for reduction #}
    {% for arg in parloop.globals %}
    {% if arg.acc != 'OP_READ' %}
    {% call op_opt(arg) %}
    allocate( reductionArrayHost{{ arg.var }}(numberOfThreads * ({{ arg.dim-1}}/64 + 1) * 64) )
    DO i1 = 1, numberOfThreads, 1
      DO i2 = 1, {{ arg.dim }}, 1
    {% if arg.acc == 'OP_INC' %}
        reductionArrayHost{{ arg.var }}((i1 -1) * ({{ arg.dim-1}}/64 + 1) * 64 + i2) = 0
    {% elif arg.acc == 'OP_MIN' %}
        reductionArrayHost{{ arg.var }}((i1 -1) * ({{ arg.dim-1}}/64 + 1) * 64 + i2) = MIN_VAL {# TODO - what size ?#}
    {% elif arg.acc == 'OP_MAX' %}
        reductionArrayHost{{ arg.var }}((i1 -1) * ({{ arg.dim-1}}/64 + 1) * 64 + i2) = MAX_VAL {# TODO - what size ?#}
    {% endif %}
      END DO
    END DO
    {% endcall %}
    {% endif %}
    {#  #}
    {% endfor %}

    {# Indirect - loop call#}
    {% if parloop.indirection %}
    blockOffset = 0
    DO i1 = 0, actualPlan_{{ parloop.name }}%ncolors-1, 1
      IF (i1 .EQ. actualPlan_{{ parloop.name }}%ncolors_core) THEN
        CALL op_mpi_wait_all(numberOfOpDats,opArgArray)
      END IF

      nblocks = ncolblk_{{ parloop.name }}(i1 + 1)
      !$OMP PARALLEL DO private (threadID, blockID, nelem, offset_b)
      DO i2 = 0, nblocks-1, 1
        threadID = omp_get_thread_num()
        blockID = blkmap_{{ parloop.name }}(i2+blockOffset+1)
        nelem = nelems_{{ parloop.name }}(blockID+1)
        offset_b = offset_{{ parloop.name }}(blockID+1)
        CALL {{ parloop.name }}_wrap( &
          {# Globals #}
          {% for arg in parloop.globals  %}
          reductionArrayHost{{ arg.var }}(threadID * ({{ arg.dim-1}}/64 + 1) * 64 + 1), &
          {% endfor %}
          {# Directs #}
          {% for arg in parloop.directs %}
          & dirDat_{{ arg.var }}, &
          {% endfor %}
          {# Indirects #}
          {% for arg in parloop.indirectVars %}
          & indDat_{{ arg.var }}, &
          {% endfor %}
          {# Maps #}
          {% for arg in parloop.indirectMaps  %}
          & map_{{ arg.map }}, &
          & mapDim_{{ arg.map }}, &
          {% endfor %}
          {#  #}
          & offset_b, offset_b+nelem )
      END DO
      !$OMP END PARALLEL DO
      blockOffset = blockOffset + nblocks
    END DO
    {# Direct - loop call#}
    {% else %}
    !$OMP PARALLEL DO private (sliceStart,sliceEnd,i1,threadID)
    DO i1 = 0, numberOfThreads-1, 1
      sliceStart = opSetCore%size * i1 / numberOfThreads
      sliceEnd = opSetCore%size * (i1 + 1) / numberOfThreads
      threadID = omp_get_thread_num()
      CALL {{ parloop.name }}_wrap( &
      {# Globals #}
      {% for arg in parloop.globals  %}
      reductionArrayHost{{ arg.var }}(threadID * ({{ arg.dim-1}}/64 + 1) * 64 + 1), &
      {% endfor %}
      {# Directs #}
      {% for arg in parloop.directs %}
      & dirDat_{{ arg.var }}, &
      {% endfor %}
      {#  #}
      & sliceStart, sliceEnd)
    END DO
    !$OMP END PARALLEL DO
    {% endif %}
    IF ((n_upper .EQ. 0) .OR. (n_upper .EQ. opSetCore%core_size)) THEN
    CALL op_mpi_wait_all(numberOfOpDats, opArgArray)
    END IF

    CALL op_mpi_set_dirtybit(numberOfOpDats,opArgArray)

    {# Reductions #}
    {% for arg in parloop.globals %}
    {% if arg.acc != 'OP_READ' %}
    {% call op_opt(arg) %}
    DO i1 = 1, numberOfThreads, 1
      DO i2 = 1, {{ arg.dim }}, 1
    {% if arg.acc == 'OP_INC' %}
        gblDat_{{ arg.var }}(i2) = gblDat_{{ arg.var }}(i2) + reductionArrayHost{{ arg.var }}((i1 -1) * ({{ arg.dim-1}}/64 + 1) * 64 + i2)
    {% elif arg.acc == 'OP_MIN' %}
        gblDat_{{ arg.var }}(i2) = MIN(gblDat_{{ arg.var }}(i2), reductionArrayHost{{ arg.var }}((i1 -1) * ({{ arg.dim-1}}/64 + 1) * 64 + i2)
    {% elif arg.acc == 'OP_MAX' %}
        gblDat_{{ arg.var }}(i2) = MAX(gblDat_{{ arg.var }}(i2), reductionArrayHost{{ arg.var }}((i1 -1) * ({{ arg.dim-1}}/64 + 1) * 64 + i2)
    {% endif %}
      END DO
    END DO
    {% endcall %}
    {#  #}
    deallocate( reductionArrayHost{{ arg.var }} )
    {#  #}
    {% call op_opt(arg) %}
    {% if arg.typ in ['real(8)', 'REAL(kind=8)', 'real*8', 'r8'] %}
    CALL op_mpi_reduce_double(opArg{{ arg.i+1 }}, opArg{{ arg.i+1 }}%data)
    {% elif arg.typ in ['real(4)', 'REAL(kind=4)', 'real*4', 'r4'] %}
    CALL op_mpi_reduce_float(opArg{{ arg.i+1 }}, opArg{{ arg.i+1 }}%data)
    {% elif arg.typ in ['integer(4)', 'INTEGER(kind=4)', 'integer*4', 'i4'] %}
    {CALL op_mpi_reduce_int(opArg{{ arg.i+1 }}, opArg{{ arg.i+1 }}%data)
    {% elif arg.typ in ['logical', 'logical*1'] %}
    CALL op_mpi_reduce_bool(opArg{{ arg.i+1 }}, opArg{{ arg.i+1 }}%data)
    {% endif %}
    {% endcall %}
    {% endif %}
    {% endfor %}

    CALL op_timers_core(endTime)

    {% if not parloop.indirection %}
    {# No indirection #}
    dataTransfer = 0.0
    {%   for arg in parloop.args %}
    {%     call op_opt(arg) %}
    dataTransfer = dataTransfer + opArg{{ arg.i+1 }}%size
    {%-    if arg is not global %} * getSetSizeFromOpArg(opArg{{ arg.i+1 }}){% endif %}
    {%-    if arg is not r_or_w_acc %} * 2.d0{% endif %}
    {{''}}
    {%     endcall %}
    {%   endfor %}
    returnSetKernelTiming = setKernelTime( &
    & {{ id }}, kernel//C_NULL_CHAR, &
    & endTime-startTime, dataTransfer, 0.00000_4, 1 &
    & )
    {% else %}
    {# Indirection #}
    returnSetKernelTiming = setKernelTime( &
    & {{ id }}, kernel//C_NULL_CHAR, &
    & endTime-startTime, actualPlan_{{ parloop.name }}%transfer, &
    & actualPlan_{{ parloop.name }}%transfer2, 1 &
    & )
    {% endif %}

  END SUBROUTINE

END MODULE
