{%- macro map_lookup(arg) -%}
map{{arg.map_id}}({{arg.map_idx - 1}} * set_size + n)
    {{-(" * %d" % lh.dat(arg).dim) if lh.dat(arg) is not soa}}
{%- endmacro -%}

{%- macro arg_to_pointer_cuda(arg) -%}
    {%- if arg is gbl -%}
gbl{{arg.id}}{{"_local" if arg is reduction}}
    {%- elif arg is direct -%}
dat{{arg.dat_id}}((n - 1) * {{lh.dat(arg).dim}} + 1)
    {%- elif arg is inc and target.config.atomics %}
arg{{arg.id}}_{{arg.map_idx}}_local
    {%- else -%}
dat{{arg.dat_id}}({{map_lookup(arg)}} + 1)
    {%- endif -%}
{%- endmacro -%}

{%- macro kernel_call() -%}
call op_cuda_{{lh.kernel}}<<<num_blocks, block_size
{{-", shared_size" if lh.args|gbl|reduction|length > 0}}>>>( &
    {% for dat in lh.dats %}
    dat{{dat.id}}_d, &
    {% endfor %}
    {% for map in lh.maps %}
    map{{map.id}}_d, &
    {% endfor %}
    {% for arg in lh.args|gbl %}
    gbl{{arg.id}}_d, &
    {% endfor %}
    {% for extra_arg in varargs %}
    {{extra_arg}}{{"," if not loop.last}} &
    {% endfor %}
)
{%- endmacro -%}

{%- macro type_c(arg) -%}
    {%- if arg.access_type is instance(OP.Int) -%}
        int
    {%- elif arg.access_type is instance(OP.Bool) -%}
        bool
    {%- elif arg.access_type.size == 32 -%}
        float
    {%- else -%}
        double
    {%- endif -%}
{%- endmacro -%}

attributes(device) &
{{kernel_func}}

attributes(global) &
subroutine op_cuda_{{lh.kernel}}( &
{{"    optflags, &\n" if lh.args|opt|length > 0-}}
{% for dat in lh.dats %}
    dat{{dat.id}}, &
{% endfor %}
{% for map in lh.maps %}
    map{{map.id}}, &
{% endfor %}
{% for arg in lh.args|gbl %}
    gbl{{arg.id}}, &
{% endfor %}
{% if lh is indirect %}
    {{"col_reord, &\n" if target.config.color2-}}
    start, &
    end, &
{% endif %}
    set_size &
)
    implicit none

    ! parameters
{% if lh.args|opt|length > 0 %}
    integer(4), value :: optflags

{% endif %}
{% for dat in lh.dats %}
    {{dat.typ}}, dimension(*) :: dat{{dat.id}}{{"\n" if loop.last}}
{% endfor %}
{% for map in lh.maps %}
    integer(4), dimension(*) :: map{{map.id}}{{"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|gbl %}
    {{arg.typ}}, dimension({{arg.dim}}{{", *" if arg is reduction}}) :: gbl{{arg.id}}{{"\n" if loop.last}}
{% endfor %}
{% if lh is indirect %}
    {% if target.config.color2 %}
    integer(4), dimension(0:*) :: col_reord
    {% endif %}
    integer(4), value :: start, end
{% endif %}
    integer(4), value :: set_size

    ! locals
{% for arg in lh.args|gbl|reduction %}
    {{arg.typ}}, dimension({{arg.dim}}) :: gbl{{arg.id}}_local{{"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|indirect|reduction if target.config.atomics %}
    {{lh.dat(arg).typ}}, dimension({{lh.dat(arg).dim}}) :: arg{{arg.id}}_{{arg.map_idx}}_local{{"\n" if loop.last}}
{% endfor %}
    integer(4) :: thread_id, d, n, ret

{% for arg in lh.args|gbl|reduction %}
    do d = 1, {{arg.dim}}
        gbl{{arg.id}}_local(d) = {% if arg is inc -%}
            0
        {%- else -%}
            gbl{{arg.id}}(d, blockIdx%x)
        {%- endif +%}
    end do

{% endfor %}
    thread_id = threadIdx%x + (blockIdx%x - 1) * blockDim%x

{% if lh is direct %}
    do n = thread_id, set_size, blockdim%x * griddim%x
        call op2_k{{kernel_idx}}_{{lh.kernel}}( &
    {% for arg  in lh.args %}
            {{arg_to_pointer_cuda(arg)}}{{"," if not loop.last}} &
    {% endfor %}
        )
    end do
{% else %}
    if (thread_id + start <= end) then
        n = {{"thread_id + start" if target.config.atomics else "col_reord(thread_id + start)"}}

    {% for arg in lh.args|indirect|reduction if target.config.atomics %}
        arg{{arg.id}}_{{arg.map_idx}}_local = 0{{"\n" if loop.last}}
    {% endfor %}
        call op2_k{{kernel_idx}}_{{lh.kernel}}( &
    {% for arg  in lh.args %}
            {{arg_to_pointer_cuda(arg)}}{{"," if not loop.last}} &
    {% endfor %}
        )
    {% for arg in lh.args|indirect|reduction if target.config.atomics %}

        do d = 1, {{lh.dat(arg).dim}}
            ret = atomicAdd(dat{{arg.dat_id}}({{map_lookup(arg)}} + d), &
                arg{{arg.id}}_{{arg.map_idx}}_local(d))
        end do
    {% endfor %}
    end if
{% endif %}
{% for arg in lh.args|gbl|reduction %}

    do d = 1, {{arg.dim}}
        ret = {%+ if arg is inc -%}
        atomicAdd
        {%- elif arg is min -%}
        atomicMin
        {%- elif arg is max -%}
        AtomicMax
        {%- endif %}(gbl{{arg.id}}(d, blockIdx%x), gbl{{arg.id}}_local(d))
    end do
{% endfor %}
end subroutine

subroutine {{lh.kernel}}_host( &
    name, &
    set, &
{% for arg in lh.args %}
    arg{{arg.id}}{{"," if not loop.last}} &
{% endfor %}
)
    implicit none

    ! parameters
    character(kind=c_char, len=*) :: name
    type(op_set) :: set

{% for arg in lh.args %}
    type(op_arg) :: arg{{arg.id}}
{% endfor %}

    ! locals
    type(op_arg), dimension({{lh.args|length}}) :: args

    integer(4) :: set_size, col, block, round, dim, err

{% for dat in lh.dats %}
    {{dat.typ}}, dimension(:), pointer, device :: dat{{dat.id}}_d{{"\n" if loop.last}}
{% endfor %}
{% for map in lh.maps %}
    integer(4), dimension(:), pointer, device :: map{{map.id}}_d{{"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|gbl %}
    {{arg.typ}}, dimension(:), pointer :: gbl{{arg.id}}
    {% if arg is reduction %}
    {{arg.typ}}, dimension(:, :), allocatable, save :: gbl{{arg.id}}_h
    {% endif %}
    {{arg.typ}}, dimension(:{{", :" if arg is not read}}), allocatable, save, device :: gbl{{arg.id}}_d

{% endfor %}
    real(8) :: start_time, end_time
    real(4) :: transfer

    integer(4) :: num_blocks, max_blocks, block_size
    integer(4) :: shared_size

{% if lh is indirect %}
    integer(4) :: start, end

{% endif %}
{% if lh is indirect and target.config.color2 %}
    integer(4) :: num_dats_indirect
    integer(4), dimension({{lh.args|length}}) :: dats_indirect

    integer(4) :: part_size

    type(op_plan), pointer :: plan
    integer(4), dimension(:), pointer :: plan_ncolblk, plan_color2_offsets
    integer(4), dimension(:), pointer, device :: plan_col_reord

{% endif %}
{% for arg in lh.args %}
    args({{loop.index}}) = arg{{arg.id}}
{% endfor %}

    call op_timers_core(start_time)

    set_size = op_mpi_halo_exchanges_grouped(set%setcptr, size(args), args, 2)

    if (set_size == 0) then
        call op_mpi_wait_all_grouped(size(args), args, 2)
{% for arg in lh.args|gbl|reduction %}
        call op_mpi_reduce_{{type_c(arg)}}(arg{{arg.id}}, arg{{arg.id}}%data)
{% endfor %}
        call op_mpi_set_dirtybit_cuda(size(args), args)
        err = cudaDeviceSynchronize()

        if (err .ne. 0) then
            print *, cudaGetErrorString(err)
        end if

        return
    end if

    block_size = getblocksize(name // c_null_char, set%setptr%size)

{% if lh is direct %}
    num_blocks = 200
    max_blocks = num_blocks
{% elif target.config.atomics %}
    max_blocks = (max(set%setptr%core_size, &
        set%setptr%size + set%setptr%exec_size - set%setptr%core_size) - 1) / block_size + 1
{% elif target.config.color2 %}
    num_dats_indirect = {{lh.dats|indirect(lh)|length}}
    dats_indirect = (/
    {%- for arg in lh.args -%}
        {{lh.dats|indirect(lh)|index(lh.dat(arg)) if arg is indirect else "-1"}}
        {{-", " if not loop.last}}
    {%- endfor -%}
    /)

    part_size = getpartitionsize(name // c_null_char, set%setptr%size)
    plan => fortranplancaller( &
        name // c_null_char, &
        set%setcptr, &
        part_size, &
        size(args), &
        args, &
        num_dats_indirect, &
        dats_indirect &
    )

    call c_f_pointer(plan%ncolblk, plan_ncolblk, (/ plan%ncolors /))
    call c_f_pointer(plan%color2_offsets, plan_color2_offsets, (/ plan%ncolors + 1 /))
    call c_f_pointer(plan%col_reord, plan_col_reord, (/ set%setptr%size + set%setptr%exec_size /))

    max_blocks = 0
    do col = 1, plan%ncolors
        max_blocks = max(max_blocks, plan_ncolblk(col))
    end do
{% endif %}

{% for dat in lh.dats %}
    call c_f_pointer(arg{{dat.arg_id}}%data_d, dat{{dat.id}}_d, (/arg{{dat.arg_id}}%dim * getsetsizefromoparg(arg{{dat.arg_id}})/))
        {{-"\n" if loop.last}}
{% endfor %}
{% for map in lh.maps %}
    call c_f_pointer(arg{{map.arg_id}}%map_data_d, map{{map.id}}_d, (/set%setptr%size * getmapdimfromoparg(arg{{map.arg_id}})/))
        {{-"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|gbl %}
    call c_f_pointer(arg{{arg.id}}%data, gbl{{arg.id}}, (/{{arg.dim}}/)){{-"\n" if loop.last}}
{% endfor %}
{% for arg in lh.args|gbl|read %}
    if (.not. allocated(gbl{{arg.id}}_d)) then
        allocate(gbl{{arg.id}}_d({{arg.dim}}))
    end if

    gbl{{arg.id}}_d = gbl{{arg.id}}

{% endfor %}
    shared_size = 0

{% for arg in lh.args|gbl|reduction %}
    shared_size = max(shared_size, block_size * sizeof(gbl{{arg.id}}(1)))

    if (.not. allocated(gbl{{arg.id}}_d)) then
        allocate(gbl{{arg.id}}_d({{arg.dim}}, max_blocks))
    end if

    {% if arg is reduction %}
    if (.not. allocated(gbl{{arg.id}}_h)) then
        allocate(gbl{{arg.id}}_h({{arg.dim}}, max_blocks))
    end if

    {% endif %}
    {% if arg is inc %}
    gbl{{arg.id}}_d = 0
    {% else %}
    do block = 1, max_blocks
        gbl{{arg.id}}_d(:, block) = gbl{{arg.id}}
    end do
    {% endif %}

{% endfor %}
{% if lh is direct %}
    {{kernel_call("set%setptr%size")|indent}}
{% elif target.config.atomics %}
    do round = 1, {{"3" if lh.args|gbl|reduction|length > 0 else "2"}}
        if (round == 2) then
            call op_mpi_wait_all_grouped(size(args), args, 2)
        end if

    {% if lh.args|gbl|reduction|length > 0 %}
        start = merge(0, merge(set%setptr%core_size, set%setptr%size, round == 2), round == 1)
        end = merge(set%setptr%core_size, merge(set%setptr%size, set%setptr%size + set%setptr%exec_size, round == 2), round == 1)
    {% else %}
        start = merge(0, set%setptr%core_size, round == 1)
        end = merge(set%setptr%core_size, set%setptr%size + set%setptr%exec_size, round == 1)
    {% endif %}

        if (end - start > 0) then
            num_blocks = (end - start - 1) / block_size + 1
            {{kernel_call("start", "end", "set%setptr%size + set%setptr%exec_size")|indent(12)}}
        end if
    end do
{% else %}
    do col = 1, plan%ncolors
        if ((col - 1) == plan%ncolors_core) then
            call (size(args), args, 2)
        end if

        start = plan_color2_offsets(col)
        end = plan_color2_offsets(col + 1)

        num_blocks = (end - start - 1) / block_size + 1

        {{kernel_call("plan_col_reord", "start", "end", "set%setptr%size + set%setptr%exec_size")}}
    end do
{% endif %}

{% for arg in lh.args|gbl|reduction %}
    gbl{{arg.id}}_h = gbl{{arg.id}}_d

    do block = 1, max_blocks
        do dim = 1, {{arg.dim}}
    {% if arg is inc %}
            gbl{{arg.id}}(dim) = gbl{{arg.id}}(dim) + gbl{{arg.id}}_h(dim, block)
    {% elif arg is reduction %}
            gbl{{arg.id}}(dim) = {{arg.access_type.name}}(gbl{{arg.id}}(dim), gbl{{arg.id}}_h(dim, block))
    {% endif %}
        end do
    end do

    call op_mpi_reduce_{{type_c(arg)}}(arg{{arg.id}}, arg{{arg.id}}%data)

{% endfor %}
    call op_mpi_set_dirtybit_cuda(size(args), args)

    err = cudaDeviceSynchronize()

    if (err .ne. 0) then
        print *, cudaGetErrorString(err)
    end if

    call op_timers_core(end_time)

    ! todo: review kernel transfer calculation
    transfer = 0.0

    call setkerneltime({{kernel_idx}}, name // c_null_char, end_time - start_time, transfer, 0.0, 1)
end subroutine
