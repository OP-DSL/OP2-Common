
{# Surround caller with op_opt conditional block #}
{% macro op_opt(arg) %}
{% if arg.opt %}
if (arg{{ arg.i }}.opt)
{ {{ caller() }}
}
{% else %}{{ caller() }}{% endif %}
{% endmacro %}

{# Surround caller with op_opt_cuda conditional block #}
{% macro op_opt_cuda(arg) %}
{% if arg.opt %}
if (optflags & 1 << {{ arg.optidx }})
{ {{ caller() }}
}
{% else %}{{ caller() }}{% endif %}
{% endmacro %}

{% macro op_host_stub_args(parloop) %}
int nargs = {{ parloop.nargs }};
  op_arg args[{{ parloop.nargs }}];

  {% for arg in parloop.expanded_args %}
  {% if arg.vec and arg.idx == 0 %}
  arg{{ arg.i }}.idx = 0;
  args[{{ arg.i }}] = arg{{ arg.i }};
  for(int v = 1; v < {{ arg.vec_size }}; v++) {
    {% if arg.opt is not none %}
    args[{{ arg.i }} + v] = op_opt_arg_dat(arg{{ arg.i }}.dat, v, arg{{ arg.i }}.map, {{ arg.dim }}, "{{ arg.typ }}", {{ arg.acc }});
    {% else %}
    args[{{ arg.i }} + v] = op_arg_dat(arg{{ arg.i }}.dat, v, arg{{ arg.i }}.map, {{ arg.dim }}, "{{ arg.typ }}", {{ arg.acc }});
    {% endif %}
  }
  {% elif not arg.vec %}
  args[{{ arg.i }}] = arg{{ arg.i }};
  {% endif %}
  {% endfor %}
{% endmacro %}

{% macro op_host_declare_mappings(parloop) %}
{# Declare mappings #}
{% for arg in parloop.expanded_args %}
{% if arg.indirect and arg.mapIdxIndFirst %}
int map{{ arg.mapIdxInd }}idx;
{% endif %}
{% endfor %}
{% endmacro %}

{% macro op_host_set_mappings(parloop) %}
{{ op_host_declare_mappings(parloop) }}

{# Set mappings (both non-optional and optional) #}
{% for arg in parloop.expanded_args %}
{% if arg.indirect and arg.mapIdxIndFirst %}
{%- call op_opt(arg) %}
map{{ arg.mapIdxInd }}idx = arg{{ arg.mapInd }}.map_data[n * arg{{ arg.mapInd }}.map->dim + {{ arg.idx }}];
{% endcall %}
{% endif %}
{% endfor %}
{% endmacro %}

{% macro op_host_vec_arg_arrays(parloop) %}
{# Create vec arguments #}
{% for arg in parloop.expanded_args %}
{% if arg.vec %}
{# First line and open bracket #}
{% if arg.idx == 0 %}
{{ 'const ' if arg.acc == "OP_READ" else '' }}{{ arg.typ }}* arg{{ arg.i }}_vec[] = {
{% endif %}
{# Pointer for this arg #}
  &(({{ arg.typ }}*)arg{{ arg.datInd }}.data)[{{ arg.dim }} * map{{ arg.mapIdxInd }}idx],
{# End bracket #}
{% if arg.idx == arg.vec_size - 1 %}
};
{% endif %}
{% endif %}
{% endfor %}
{% endmacro %}

{% macro op_get_stride(parloop, arg) %}
{% if arg.direct %}
direct_{{ parloop.name }}_stride_OP2CONSTANT
{% elif arg.global_ %}
(gridDim % x * blockDim % x)
{% else %}
opDat{{ arg.mapInd }}_{{ parloop.name }}_stride_OP2CONSTANT
{% endif %}
{% endmacro %}
