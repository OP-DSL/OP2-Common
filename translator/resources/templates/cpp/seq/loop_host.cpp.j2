
{# Template imports #}
{% from 'cpp/macros.j2' import op_opt, op_host_stub_args %}
{% from 'macros.j2' import comma %}

{# !!! W.I.P !!! #}

// user function
#include "../{{ parloop.kernelPath }}"

// host stub function
void op_par_loop_{{ parloop.name }}_host(
  char const *name,
  op_set set,
  {% for arg in parloop.args %}
  op_arg arg{{ arg.i }}{{ comma(loop) }}
  {% endfor %}
) {

  {{ op_host_stub_args(parloop) }}

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timing_realloc({{ id }});
  op_timers_core(&cpu_t1, &wall_t1);

  if (OP_diags>2) {
    printf(" kernel routine {{ 'with' if parloop.indirection else 'w/o' }} indirection: {{ parloop.name }}\n");
  }

  int set_size = op_mpi_halo_exchanges(set, nargs, args);

  if (set_size > 0) {
    for (int n=0; n<set_size; n++) {
      {% if parloop.indirection %}
      if (n == set->core_size) {
        op_mpi_wait_all(nargs, args);
      }
      {% for arg in parloop.indirectIdxs %}
      int map{{ loop.index - 1 }}idx;
      {% endfor %}
      {% for arg in parloop.indirectIdxs %}
      {%- call op_opt(arg) %}
      map{{ loop.index - 1 }}idx = arg{{ arg.map1st }}.map_data[n * arg{{ arg.map1st }}.map->dim + {{ arg.idx }}];
      {%- endcall %}

      {% endfor %}
      {% endif %}

      {% for arg in parloop.vecs %}
      {% if arg.acc == "OP_READ" %}
      const {{ arg.typ }}* arg{{ arg.i }}_vec[] = {
      {% else %}
      {{ arg.typ }}* arg{{ arg.i }}_vec[] = {
      {% endif %}
        {% for i in range(0, arg.idx | abs) %}
        &(({{ arg.typ }}*)arg{{ arg.i }}.data)[{{ arg.dim }} * map{{ parloop.mapIdxLookup(arg.map, i) }}idx]{{ comma(loop) }}
        {% endfor %}
      };
      {% endfor %}

      {{ parloop.kernel }}(
      {% for arg in parloop.args %}
      {% if arg.indirect %}
      {% if arg.vec %}
        arg{{ arg.i }}_vec{{ comma(loop) }}
      {% else %}
        &(({{ arg.typ }}*)arg{{ arg.arg1st }}.data)[{{ arg.dim }} * map{{ parloop.mapIdxLookup(arg.map, arg.idx) }}idx]{{ comma(loop) }}
      {% endif %}
      {% elif arg.direct %}
        &(({{ arg.typ }}*)arg{{ arg.i }}.data)[{{ arg.dim }} * n]{{ comma(loop) }}
      {% elif arg.global_ %}
        ({{ arg.typ }}*)arg{{ arg.i }}.data{{ comma(loop) }}
      {% endif %}
      {% endfor %}
      );
    }
  }

  {% if parloop.indirection %}
  if (set_size == 0 || set_size == set->core_size) {
    op_mpi_wait_all(nargs, args);
  }
  {% endif %}

  // combine reduction data
  {% for arg in parloop.globals %}
  {% if arg.acc != 'OP_READ' and arg.typ in ('int', 'float', 'double') %}
  op_mpi_reduce_{{ arg.typ }}(&arg{{ arg.i }},({{ arg.typ }}*)arg{{ arg.i }}.data);
  {% endif %}
  {% endfor %}
  op_mpi_set_dirtybit(nargs, args);

  // update kernel record
  op_timers_core(&cpu_t2, &wall_t2);
  OP_kernels[{{ id }}].name      = name;
  OP_kernels[{{ id }}].count    += 1;
  OP_kernels[{{ id }}].time     += wall_t2 - wall_t1;

  {%- if not parloop.indirection %}
  {# No indirection #}
  {% for arg in parloop.args %}
  {% if arg is not global %}
  {%- call op_opt(arg) %}
  OP_kernels[{{ id }}].transfer += (float)set->size * arg{{ arg.i }}.size{% if arg.acc != 'OP_READ' %} * 2.0f{% endif %};
  {%- endcall %}
  {% endif %}
  {% endfor %}
  {% else %}
  {# Indirection #}
  {% for arg in parloop.uniqueVars %}
  {%- call op_opt(arg) %}
  OP_kernels[{{ id }}].transfer += (float)set->size * arg{{ arg.i }}.size{% if arg is not r_or_w_acc %} * 2.0f{% endif %};
  {%- endcall %}
  {% endfor %}

  {% for arg in parloop.indirectMaps %}
  OP_kernels[{{ id }}].transfer += (float)set->size * arg{{ arg.i }}.map->dim * 4.0f;
  {% endfor %}
  {% endif %}
}
