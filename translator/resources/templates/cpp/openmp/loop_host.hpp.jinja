{% extends "cpp/loop_host.hpp.jinja" %}

{%- macro arg_to_pointer(arg, idx) -%}
    {%- if arg is gbl -%}
gbl_{{arg.ptr}}
    {%- elif arg is direct -%}
dat_{{arg.dat_ptr}} + n * {{arg.dat_dim}}
    {%- else -%}
dat_{{arg.dat_ptr}} + map_{{arg.map_ptr}}[n * {{lh.findMap(arg.map_ptr)[0].dim}} + {{arg.map_idx}}] * {{arg.dat_dim}}
    {%- endif -%}
{%- endmacro -%}

{%- macro arg_to_pointer_local(arg, idx) -%}
    {%- if arg is read -%}
{{arg_to_pointer(arg, idx)}}
    {%- else -%}
arg{{idx}}{{"_%s" % (arg.map_idx) if arg is indirect-}}_local[lane]
    {%- endif -%}
{%- endmacro -%}

{% block host_prologue %}
    {% if target.config.vectorise %}
#define SIMD_LEN 8
    {% endif %}

void {{lh.kernel.name}}_wrapper(
    {% for dat, idx in lh.dats.items() %}
    {{"const " if dat is read_in(lh)}}{{dat.typ}} *__restrict__ dat_{{dat.ptr}}_u,
    {% endfor %}
    {% for map, idx in lh.maps.items() %}
    const int *__restrict__ map_{{map.ptr}}_u,
    {% endfor %}
    {% for arg, idx in lh.args|gbl %}
    {{"const " if arg is read}}{{arg.typ}} *__restrict__ gbl_{{arg.ptr}},
    {% endfor %}
    int start,
    int end
) {
    {% for dat, idx in lh.dats.items() %}
    {{"const " if dat is read_in(lh)}}{{dat.typ}} *__restrict__ dat_{{dat.ptr}} = assume_aligned(dat_{{dat.ptr}}_u);
    {% endfor %}
    {% for map, idx in lh.maps.items() %}
    const int *__restrict__ map_{{map.ptr}} = assume_aligned(map_{{map.ptr}}_u);
    {% endfor %}

    {% if target.config.vectorise %}
    int block = start;
    for (; block + SIMD_LEN < end; block += SIMD_LEN) {
        {% for arg, idx in lh.args_expanded|dat if arg is not read %}
        alignas(SIMD_LEN * 8) {{arg.dat_typ}} arg{{idx}}{{"_%s" % (arg.map_idx) if arg is indirect-}}
            _local[SIMD_LEN][{{arg.dat_dim}}]{{-" = {0}" if arg is inc}};
        {% endfor %}
        {% for arg, idx in lh.args|gbl|reduction %}
        alignas(SIMD_LEN * 8) {{arg.typ}} arg{{idx}}_local[SIMD_LEN][{{arg.dim}}]{{" = {0}" if arg is inc}};
        {% endfor %}

        for (int lane = 0; lane < SIMD_LEN; ++lane) {
            int n = block + lane;

            {% for arg, idx in lh.args_expanded|dat if arg is read_write %}
            for (int d = 0; d < {{arg.dat_dim}}; ++d) {
                arg{{idx}}_local[lane][d] = ({{arg_to_pointer(arg, idx)}})[d];
            }{{"\n" if not loop.last}}
            {% endfor %}
            {% for arg, idx in lh.args|gbl|reduction if arg is not inc %}
            for (int d = 0; d < {{arg.dim}}; ++d) {
                arg{{idx}}_local[lane][d] = ({{arg_to_pointer(arg, idx)}})[d];
            }{{"\n" if not loop.last}}
            {% endfor %}
        }

        #pragma omp simd
        for (int lane = 0; lane < SIMD_LEN; ++lane) {
            int n = block + lane;

        {% for arg, idx in lh.args|vec %}
            {{"const " if arg is read}}{{arg.dat_typ}} *arg{{idx}}_vec[] = {
            {% for arg_expanded, idx2 in lh.args_expanded if idx2 == idx %}
                {{arg_to_pointer_local(arg_expanded, idx)}}{{"," if not loop.last}}
            {% endfor %}
            };

        {% endfor %}
            {{lh.kernel.name}}(
        {% for arg, idx in lh.args %}
            {% if arg is not vec %}
                {{arg_to_pointer_local(arg, idx)}}{{"," if not loop.last}}
            {% else %}
                arg{{idx}}_vec{{"," if not loop.last}}
            {% endif %}
        {% endfor %}
            );
        }

        for (int lane = 0; lane < SIMD_LEN; ++lane) {
            int n = block + lane;
        {% for arg, idx in lh.args_expanded|dat if arg is not read %}

            for (int d = 0; d < {{arg.dat_dim}}; ++d) {
                ({{arg_to_pointer(arg, idx)}})[d] {{"+" if arg is inc-}}= {{arg_to_pointer_local(arg, idx)}}[d];
            }
        {% endfor %}
        {% for arg, idx in lh.args|gbl|reduction %}

            for (int d = 0; d < {{arg.dim}}; ++d) {
            {% if arg is inc %}
                {{arg_to_pointer(arg, idx)}}[d] += {{arg_to_pointer_local(arg, idx)}}[d];
            {% else %}
                {{arg_to_pointer(arg, idx)}}[d] = {{arg.access_type.name if arg is not inc-}}
                    ({{arg_to_pointer(arg, idx)}}[d], {{arg_to_pointer_local(arg, idx)}}[d]);
            {% endif %}
            }
        {% endfor %}
        }
    }

    for (int n = block; n < end; ++n) {
        {% for arg, idx in lh.args|vec %}
        {{"const " if arg.access_type == OP.AccessType.READ}}{{arg.dat_typ}} *arg{{idx}}_vec[] = {
            {% for arg_expanded, idx2 in lh.args_expanded if idx2 == idx %}
            {{arg_to_pointer(arg_expanded, idx)}}{{"," if not loop.last}}
            {% endfor %}
        };

        {% endfor %}
        {{lh.kernel.name}}(
        {% for arg, idx in lh.args %}
            {% if arg is not vec %}
            {{arg_to_pointer(arg, idx)}}{{"," if not loop.last}}
            {% else %}
            arg{{idx}}_vec{{"," if not loop.last}}
            {% endif %}
        {% endfor %}
        );
    }
    {% else %}
    for (int n = start; n < end; ++n) {
        {% for arg, idx in lh.args|vec %}
        {{"const " if arg.access_type == OP.AccessType.READ}}{{arg.dat_typ}} *arg{{idx}}_vec[] = {
            {% for arg_expanded, idx2 in lh.args_expanded if idx2 == idx %}
            {{arg_to_pointer(arg_expanded, idx)}}{{"," if not loop.last}}
            {% endfor %}
        };

        {% endfor %}
        {{lh.kernel.name}}(
        {% for arg, idx in lh.args %}
            {% if arg is not vec %}
            {{arg_to_pointer(arg, idx)}}{{"," if not loop.last}}
            {% else %}
            arg{{idx}}_vec{{"," if not loop.last}}
            {% endif %}
        {% endfor %}
        );
    }
    {% endif %}
}

{{super()}}
    {% if lh is indirect %}
{{indirect_dat_def()}}

#ifdef OP_PART_SIZE_{{lh.kernel_idx}}
    int part_size = OP_PART_SIZE_{{lh.kernel_idx}};
#else
    int part_size = OP_part_size;
#endif

    op_plan *plan = op_plan_get_stage_upload(name, set, part_size, num_args_expanded, args_expanded,
        num_dats_indirect, dats_indirect, OP_STAGE_ALL, 0);
    {% endif %}
    {% if lh is direct or lh.args|gbl|reduction|length > 0 %}

#ifdef _OPENMP
    int num_threads = omp_get_max_threads();
#else
    int num_threads = 1;
#endif
    {% endif %}
    {% for arg, idx in lh.args|gbl|reduction %}

    {{arg.typ}} *arg{{idx}}_host_data = ({{arg.typ}} *)arg{{idx}}.data;
    {{arg.typ}} gbl_{{arg.ptr}}_local[num_threads * 64];

    for (int thread = 0; thread < num_threads; ++thread) {
        for (int d = 0; d < {{arg.dim}}; ++d)
            gbl_{{arg.ptr}}_local[thread * 64 + d] = {% if arg is inc -%}
                ZERO_{{arg.typ}}
            {%- else -%}
                arg{{idx}}_host_data[d]
            {%- endif %};
    }
    {% endfor %}
{% endblock %}

{% block host_prologue_early_exit_cleanup %}
    {% if lh is indirect %}
        op_mpi_wait_all(num_args_expanded, args_expanded);

    {% endif %}
    {% for arg, idx in lh.args|gbl|reduction %}
        op_mpi_reduce(&arg{{idx}}, ({{arg.typ}} *)arg{{idx}}.data);
    {% endfor %}
        op_mpi_set_dirtybit(num_args_expanded, args_expanded);
{% endblock %}

{% block host_loop %}
    {% if lh is direct %}
    #pragma omp parallel for
    for (int thread = 0; thread < num_threads; ++thread) {
        int start = (set->size * thread) / num_threads;
        int end = (set->size * (thread + 1)) / num_threads;

        {{lh.kernel.name}}_wrapper(
        {% for dat, idx in lh.dats.items() %}
            ({{dat.typ}} *)arg{{idx}}.data,
        {% endfor %}
        {% for arg, idx in lh.args|gbl %}
            {% if arg is reduction %}
            gbl_{{arg.ptr}}_local + 64 * omp_get_thread_num(),
            {% else %}
            ({{arg.typ}} *)arg{{idx}}.data,
            {% endif %}
        {% endfor %}
            start,
            end
        );
    }
    {% else %}
    int block_offset = 0;
    for (int col = 0; col < plan->ncolors; ++col) {
        if (col == plan->ncolors_core)
            op_mpi_wait_all(num_args_expanded, args_expanded);

        int num_blocks = plan->ncolblk[col];

        #pragma omp parallel for
        for (int block_idx = 0; block_idx < num_blocks; ++block_idx) {
            int block_id = plan->blkmap[block_idx + block_offset];
            int num_elem = plan->nelems[block_id];
            int offset = plan->offset[block_id];

            {{lh.kernel.name}}_wrapper(
        {% for dat, idx in lh.dats.items() %}
                ({{dat.typ}} *)arg{{idx}}.data,
        {% endfor %}
        {% for map, idx in lh.maps.items() %}
                arg{{idx}}.map_data,
        {% endfor %}
        {% for arg, idx in lh.args|gbl %}
            {% if arg is reduction %}
                gbl_{{arg.ptr}}_local + 64 * omp_get_thread_num(),
            {% else %}
                ({{arg.typ}} *)arg{{idx}}.data,
            {% endif %}
        {% endfor %}
                offset,
                offset + num_elem
            );
        }

        block_offset += num_blocks;
        {% if direct or lh.args|gbl|reduction|length > 0 %}

        if (col != plan->ncolors_owned - 1)
            continue;

            {% for arg, idx in lh.args|gbl|reduction %}
        for (int thread = 0; thread < num_threads; ++thread) {
            for (int d = 0; d < {{arg.dim}}; ++d)
                {% if arg is inc %}
                arg{{idx}}_host_data[d] += gbl_{{arg.ptr}}_local[thread * 64 + d];
                {% else %}
                arg{{idx}}_host_data[d] = {{arg.access_type.name-}}
                    (arg{{idx}}_host_data[d], gbl_{{arg.ptr}}_local[thread * 64 + d]);
                {% endif %}
        }
            {% endfor %}
        {% endif  %}
    }
    {% endif %}
{% endblock %}

{% block host_epilogue %}
    {% if lh is indirect -%} {# TODO: is this indirect check necessary? #}
    if (set_size == set->core_size)
        op_mpi_wait_all(num_args_expanded, args_expanded);

    {% endif %}
    {% if lh is direct %}
        {% for arg, idx in lh.args|gbl|reduction %}
    for (int thread = 0; thread < num_threads; ++thread) {
        for (int d = 0; d < {{arg.dim}}; ++d)
            {% if arg is inc %}
            arg{{idx}}_host_data[d] += gbl_{{arg.ptr}}_local[thread * 64 + d];
            {% else %}
            arg{{idx}}_host_data[d] = {{arg.access_type.name-}}
                (arg{{idx}}_host_data[d], gbl_{{arg.ptr}}_local[thread * 64 + d]);
            {% endif %}
    }
            {% endfor %}

    {% endif %}
    {% for arg, idx in lh.args|gbl|reduction %}
    op_mpi_reduce(&arg{{idx}}, arg{{idx}}_host_data);
    {% endfor %}
    op_mpi_set_dirtybit(num_args_expanded, args_expanded);

{{super()}}
{% endblock %}
