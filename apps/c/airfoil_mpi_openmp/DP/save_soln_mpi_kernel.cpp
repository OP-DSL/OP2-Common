// 
// auto-generated by op2.m on 30-May-2011 22:03:11 
//
#include <op_openmp_rt_support.h>


// user function                                              
                                                              
#include "save_soln.h"                                        
                                                              
                                                              
// x86 kernel function                                        
                                                              
void op_x86_save_soln(                                        
  double *arg0,                                                
  double *arg1,                                                
  int   start,                                                
  int   finish ) {                                            
                                                              
                                                              
  // process set elements                                     
                                                              
  for (int n=start; n<finish; n++) {                          
                                                              
    // user-supplied kernel call                              
                                                              
    save_soln( arg0+n*4,                                      
               arg1+n*4 );                                    
  }                                                           
}                                                             
                                                              
                                                              
// host stub function                                         
                                                              
void op_par_loop_save_soln(char const *name, op_set set,      
  op_arg arg0,                                                
  op_arg arg1 ){                                              
                                                              
  int sent[2] = {0,0,};   
  if(arg0.idx != -1 || arg1.idx != -1 )//indirect loop
  {
      if (OP_diags==1) { 
      	  if(arg0.argtype == OP_ARG_DAT) reset_halo(arg0);
      	  if(arg1.argtype == OP_ARG_DAT) reset_halo(arg1);

      }
  
      //for each indirect data set
      if(arg0.argtype == OP_ARG_DAT) sent[0] = exchange_halo(arg0); 
      if(arg1.argtype == OP_ARG_DAT) sent[1] = exchange_halo(arg1);
  }
  
  //wait for comms to complete
  if(arg0.argtype == OP_ARG_DAT && sent[0] == 1 )wait_all(arg0);
  if(arg1.argtype == OP_ARG_DAT && sent[1] == 1 )wait_all(arg1);


  if (OP_diags>2) {                                           
    printf(" kernel routine w/o indirection:  save_soln \n"); 
  }                                                           
                                                              
  // initialise timers                                        
                                                              
  double cpu_t1, cpu_t2, wall_t1, wall_t2;                    
  op_timers(&cpu_t1, &wall_t1);                               
                                                              
  // set number of threads                                    
                                                              
#ifdef _OPENMP                                                
  int nthreads = omp_get_max_threads( );                      
#else                                                         
  int nthreads = 1;                                           
#endif                                                        
                                                              
  // execute plan                                             
                                                              
#pragma omp parallel for                                      
  for (int thr=0; thr<nthreads; thr++) {                      
    int start  = (set->size* thr   )/nthreads;                
    int finish = (set->size*(thr+1))/nthreads;                
    op_x86_save_soln( (double *) arg0.data,                    
                      (double *) arg1.data,                    
                      start, finish );                        
  }                                                           
                           
  //set dirty bit on direct/indirect datasets with access OP_INC,OP_WRITE, OP_RW
  if(arg0.argtype == OP_ARG_DAT)set_dirtybit(arg0);
  if(arg1.argtype == OP_ARG_DAT)set_dirtybit(arg1);
  
  //performe any global operations
  if(arg0.argtype == OP_ARG_GBL) 
      global_reduce(&arg0);
  if(arg1.argtype == OP_ARG_GBL) 
      global_reduce(&arg1);;

  
  
  // update kernel record                                     
                                                              
  op_timers(&cpu_t2, &wall_t2);                               
  op_timing_realloc(0);                                       
  OP_kernels[0].name      = name;                             
  OP_kernels[0].count    += 1;                                
  OP_kernels[0].time     += wall_t2 - wall_t1;                
  OP_kernels[0].transfer += (double)set->size * arg0.size;     
  OP_kernels[0].transfer += (double)set->size * arg1.size;     
}                                                             
                                                              
