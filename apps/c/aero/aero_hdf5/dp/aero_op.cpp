//
// auto-generated by op2.m on 29-Oct-2012 09:32:00
//

/*
Open source copyright declaration based on BSD open source template:
http://www.opensource.org/licenses/bsd-license.php

* Copyright (c) 2009-2011, Mike Giles
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * The name of Mike Giles may not be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Mike Giles ''AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL Mike Giles BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//
// standard headers
//

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// global constants

double gm1, gm1i, wtg1[2], xi1[2], Ng1[4], Ng1_xi[4], wtg2[4], Ng2[16],
    Ng2_xi[32], minf, m2, freq, kappa, nmode, mfan;

//
// OP header file
//

#include "op_lib_cpp.h"
int op2_stride = 1;
#define OP2_STRIDE(arr, idx) arr[op2_stride * (idx)]

//
// op_par_loop declarations
//

void op_par_loop_res_calc(char const *, op_set, op_arg, op_arg, op_arg, op_arg);

void op_par_loop_dirichlet(char const *, op_set, op_arg);

void op_par_loop_init_cg(char const *, op_set, op_arg, op_arg, op_arg, op_arg,
                         op_arg);

void op_par_loop_spMV(char const *, op_set, op_arg, op_arg, op_arg);

void op_par_loop_dotPV(char const *, op_set, op_arg, op_arg, op_arg);

void op_par_loop_updateUR(char const *, op_set, op_arg, op_arg, op_arg, op_arg,
                          op_arg);

void op_par_loop_dotR(char const *, op_set, op_arg, op_arg);

void op_par_loop_updateP(char const *, op_set, op_arg, op_arg, op_arg);

void op_par_loop_update(char const *, op_set, op_arg, op_arg, op_arg, op_arg);

#include "op_lib_mpi.h"

//
// kernel routines for parallel loops
//

#include "dirichlet.h"
#include "dotPV.h"
#include "dotR.h"
#include "init_cg.h"
#include "res_calc.h"
#include "spMV.h"
#include "update.h"
#include "updateP.h"
#include "updateUR.h"

// main program

int main(int argc, char **argv) {
  // OP initialisation

  op_init(argc, argv, 2);

  int *bnode, *cell;
  double *xm; //, *q;

  int nnode, ncell, nbnodes, niter;
  double rms = 1;

  // set constants and initialise flow field and residual

  op_printf("initialising flow field \n");

  double gam = 1.4;
  gm1 = gam - 1.0;
  gm1i = 1.0 / gm1;

  wtg1[0] = 0.5;
  wtg1[1] = 0.5;
  xi1[0] = 0.211324865405187;
  xi1[1] = 0.788675134594813;
  Ng1[0] = 0.788675134594813;
  Ng1[1] = 0.211324865405187;
  Ng1[2] = 0.211324865405187;
  Ng1[3] = 0.788675134594813;
  Ng1_xi[0] = -1;
  Ng1_xi[1] = -1;
  Ng1_xi[2] = 1;
  Ng1_xi[3] = 1;
  wtg2[0] = 0.25;
  wtg2[1] = 0.25;
  wtg2[2] = 0.25;
  wtg2[3] = 0.25;
  Ng2[0] = 0.622008467928146;
  Ng2[1] = 0.166666666666667;
  Ng2[2] = 0.166666666666667;
  Ng2[3] = 0.044658198738520;
  Ng2[4] = 0.166666666666667;
  Ng2[5] = 0.622008467928146;
  Ng2[6] = 0.044658198738520;
  Ng2[7] = 0.166666666666667;
  Ng2[8] = 0.166666666666667;
  Ng2[9] = 0.044658198738520;
  Ng2[10] = 0.622008467928146;
  Ng2[11] = 0.166666666666667;
  Ng2[12] = 0.044658198738520;
  Ng2[13] = 0.166666666666667;
  Ng2[14] = 0.166666666666667;
  Ng2[15] = 0.622008467928146;
  Ng2_xi[0] = -0.788675134594813;
  Ng2_xi[1] = 0.788675134594813;
  Ng2_xi[2] = -0.211324865405187;
  Ng2_xi[3] = 0.211324865405187;
  Ng2_xi[4] = -0.788675134594813;
  Ng2_xi[5] = 0.788675134594813;
  Ng2_xi[6] = -0.211324865405187;
  Ng2_xi[7] = 0.211324865405187;
  Ng2_xi[8] = -0.211324865405187;
  Ng2_xi[9] = 0.211324865405187;
  Ng2_xi[10] = -0.788675134594813;
  Ng2_xi[11] = 0.788675134594813;
  Ng2_xi[12] = -0.211324865405187;
  Ng2_xi[13] = 0.211324865405187;
  Ng2_xi[14] = -0.788675134594813;
  Ng2_xi[15] = 0.788675134594813;
  Ng2_xi[16] = -0.788675134594813;
  Ng2_xi[17] = -0.211324865405187;
  Ng2_xi[18] = 0.788675134594813;
  Ng2_xi[19] = 0.211324865405187;
  Ng2_xi[20] = -0.211324865405187;
  Ng2_xi[21] = -0.788675134594813;
  Ng2_xi[22] = 0.211324865405187;
  Ng2_xi[23] = 0.788675134594813;
  Ng2_xi[24] = -0.788675134594813;
  Ng2_xi[25] = -0.211324865405187;
  Ng2_xi[26] = 0.788675134594813;
  Ng2_xi[27] = 0.211324865405187;
  Ng2_xi[28] = -0.211324865405187;
  Ng2_xi[29] = -0.788675134594813;
  Ng2_xi[30] = 0.211324865405187;
  Ng2_xi[31] = 0.788675134594813;

  minf = 0.1;
  m2 = minf * minf;
  freq = 1;
  kappa = 1;
  nmode = 0;

  mfan = 1.0;

  char file[] = "FE_grid.h5";

  // declare sets, pointers, datasets and global constants

  op_set nodes = op_decl_set_hdf5(file, "nodes");
  op_set bnodes = op_decl_set_hdf5(file, "bedges");
  op_set cells = op_decl_set_hdf5(file, "cells");

  op_map pbnodes = op_decl_map_hdf5(bnodes, nodes, 1, file, "pbedge");
  op_map pcell = op_decl_map_hdf5(cells, nodes, 4, file, "pcell");

  op_dat p_xm = op_decl_dat_hdf5(nodes, 2, "double", file, "p_x");
  op_dat p_phim = op_decl_dat_hdf5(nodes, 1, "double", file, "p_phim");
  op_dat p_resm = op_decl_dat_hdf5(nodes, 1, "double", file, "p_resm");
  op_dat p_K = op_decl_dat_hdf5(cells, 16, "double:soa", file, "p_K");
  op_dat p_V = op_decl_dat_hdf5(nodes, 1, "double", file, "p_V");
  op_dat p_P = op_decl_dat_hdf5(nodes, 1, "double", file, "p_P");
  op_dat p_U = op_decl_dat_hdf5(nodes, 1, "double", file, "p_U");

  op_decl_const2("gam", 1, "double", &gam);
  op_decl_const2("gm1", 1, "double", &gm1);
  op_decl_const2("gm1i", 1, "double", &gm1i);
  op_decl_const2("m2", 1, "double", &m2);
  op_decl_const2("wtg1", 2, "double", wtg1);
  op_decl_const2("xi1", 2, "double", xi1);
  op_decl_const2("Ng1", 4, "double", Ng1);
  op_decl_const2("Ng1_xi", 4, "double", Ng1_xi);
  op_decl_const2("wtg2", 4, "double", wtg2);
  op_decl_const2("Ng2", 16, "double", Ng2);
  op_decl_const2("Ng2_xi", 32, "double", Ng2_xi);
  op_decl_const2("minf", 1, "double", &minf);
  op_decl_const2("freq", 1, "double", &freq);
  op_decl_const2("kappa", 1, "double", &kappa);
  op_decl_const2("nmode", 1, "double", &nmode);
  op_decl_const2("mfan", 1, "double", &mfan);

  op_diagnostic_output();

  op_partition("PTSCOTCH", "KWAY", cells, pcell, p_xm);

  op_printf("nodes: %d cells: %d bnodes: %d\n", nodes->size, cells->size,
            bnodes->size);
  nnode = op_get_size(nodes);
  ncell = op_get_size(cells);
  nbnodes = op_get_size(bnodes);

  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timers(&cpu_t1, &wall_t1);

  // main time-marching loop

  niter = 20;

  for (int iter = 1; iter <= niter; iter++) {

    op_par_loop_res_calc("res_calc", cells,
                         op_arg_dat(p_xm, -4, pcell, 2, "double", OP_READ),
                         op_arg_dat(p_phim, -4, pcell, 1, "double", OP_READ),
                         op_arg_dat(p_K, -1, OP_ID, 16, "double:soa", OP_WRITE),
                         op_arg_dat(p_resm, -4, pcell, 1, "double", OP_INC));

    op_par_loop_dirichlet("dirichlet", bnodes, op_arg_dat(p_resm, 0, pbnodes, 1,
                                                          "double", OP_WRITE));

    double c1 = 0;
    double c2 = 0;
    double c3 = 0;
    double alpha = 0;
    double beta = 0;

    // c1 = R'*R;
    op_par_loop_init_cg("init_cg", nodes,
                        op_arg_dat(p_resm, -1, OP_ID, 1, "double", OP_READ),
                        op_arg_gbl(&c1, 1, "double", OP_INC),
                        op_arg_dat(p_U, -1, OP_ID, 1, "double", OP_WRITE),
                        op_arg_dat(p_V, -1, OP_ID, 1, "double", OP_WRITE),
                        op_arg_dat(p_P, -1, OP_ID, 1, "double", OP_WRITE));

    // set up stopping conditions
    double res0 = sqrt(c1);
    double res = res0;
    int inner_iter = 0;
    int maxiter = 200;
    while (res > 0.1 * res0 && inner_iter < maxiter) {
      // V = Stiffness*P
      op_par_loop_spMV("spMV", cells,
                       op_arg_dat(p_V, -4, pcell, 1, "double", OP_INC),
                       op_arg_dat(p_K, -1, OP_ID, 16, "double:soa", OP_READ),
                       op_arg_dat(p_P, -4, pcell, 1, "double", OP_READ));

      op_par_loop_dirichlet("dirichlet", bnodes,
                            op_arg_dat(p_V, 0, pbnodes, 1, "double", OP_WRITE));

      c2 = 0;

      // c2 = P'*V;
      op_par_loop_dotPV("dotPV", nodes,
                        op_arg_dat(p_P, -1, OP_ID, 1, "double", OP_READ),
                        op_arg_dat(p_V, -1, OP_ID, 1, "double", OP_READ),
                        op_arg_gbl(&c2, 1, "double", OP_INC));

      alpha = c1 / c2;

      // U = U + alpha*P;
      // resm = resm-alpha*V;
      op_par_loop_updateUR("updateUR", nodes,
                           op_arg_dat(p_U, -1, OP_ID, 1, "double", OP_INC),
                           op_arg_dat(p_resm, -1, OP_ID, 1, "double", OP_INC),
                           op_arg_dat(p_P, -1, OP_ID, 1, "double", OP_READ),
                           op_arg_dat(p_V, -1, OP_ID, 1, "double", OP_RW),
                           op_arg_gbl(&alpha, 1, "double", OP_READ));

      c3 = 0;

      // c3 = resm'*resm;
      op_par_loop_dotR("dotR", nodes,
                       op_arg_dat(p_resm, -1, OP_ID, 1, "double", OP_READ),
                       op_arg_gbl(&c3, 1, "double", OP_INC));
      beta = c3 / c1;
      // P = beta*P+resm;
      op_par_loop_updateP("updateP", nodes,
                          op_arg_dat(p_resm, -1, OP_ID, 1, "double", OP_READ),
                          op_arg_dat(p_P, -1, OP_ID, 1, "double", OP_RW),
                          op_arg_gbl(&beta, 1, "double", OP_READ));
      c1 = c3;
      res = sqrt(c1);
      inner_iter++;
    }
    rms = 0;
    // phim = phim - Stiffness\Load;
    op_par_loop_update("update", nodes,
                       op_arg_dat(p_phim, -1, OP_ID, 1, "double", OP_RW),
                       op_arg_dat(p_resm, -1, OP_ID, 1, "double", OP_WRITE),
                       op_arg_dat(p_U, -1, OP_ID, 1, "double", OP_READ),
                       op_arg_gbl(&rms, 1, "double", OP_INC));
    op_printf("rms = %10.5e iter: %d\n", sqrt(rms) / sqrt(nnode), iter);
  }

  op_timing_output();
  op_timers(&cpu_t2, &wall_t2);
  op_printf("Max total runtime = %f\n", wall_t2 - wall_t1);
  op_exit();
}