#
# The following environment variables should be predefined:
#
# CUDA_INSTALL_PATH
# PARMETIS_INSTALL_PATH
# PTSCOTCH_INSTALL_PATH
# HDF5_INSTALL_PATH
#
# OP2_INSTALL_PATH
# OP2_COMPILER (gnu,intel,etc)
#

#
# set paths for header files and libraries
#
OP2_INC		= -I$(OP2_INSTALL_PATH)/c/include
OP2_LIB		= -L$(OP2_INSTALL_PATH)/c/lib

CUDA_INC	= -I$(CUDA_INSTALL_PATH)/include
CUDA_LIB	= -L$(CUDA_INSTALL_PATH)/lib64


ifeq ($(OP2_COMPILER),gnu)
  CPP		= g++
  CPPFLAGS	= -g -fPIC -DUNIX -Wall
#  CPPFLAGS	= -O3 -fPIC -DUNIX -Wall -Wextra
  OMPFLAGS	= -fopenmp
  MPICPP	= /usr/bin/mpiCC
  MPIFLAGS	= $(CCFLAGS)
else
ifeq ($(OP2_COMPILER),intel)
  CPP		= icpc
  CCFLAGS	= -O2 -vec-report -xAVX -DMPICH_IGNORE_CXX_SEEK -restrict -fno-alias -inline-forceinline -qopt-report -parallel -DVECTORIZE  #-DCOMM_PERF #-DDEBUG
  CPPFLAGS	= $(CCFLAGS)
  OMPFLAGS	= -openmp -openmp-report2
  MPICPP	= $(MPI_INSTALL_PATH)/bin/mpicxx
  NVCCFLAGS	= #-ccbin=$(MPICPP)
  MPIFLAGS	= $(CCFLAGS)
else
ifeq ($(OP2_COMPILER),pgi)
  CPP           = pgc++
  CC           = pgcc
  CCFLAGS       = -O3
  CPPFLAGS      = $(CCFLAGS)
  OMPFLAGS      = -mp
  MPICC         = $(MPI_INSTALL_PATH)/bin/mpicc
  MPICPP        = $(MPI_INSTALL_PATH)/bin/mpicxx
  MPIFLAGS      = $(CPPFLAGS)
  NVCCFLAGS     = #-ccbin=$(MPICPP)
  ACCFLAGS      = -acc -Minfo=acc -ta=tesla:cc35 -DOPENACC
else
print:
	@echo "unrecognised value for OP2_COMPILER"
endif
endif
endif

#
# set flags for NVCC compilation and linking
#
ifndef NV_ARCH
  MESSAGE=select an NVIDA device to compile in CUDA, e.g. make NV_ARCH=KEPLER
  NV_ARCH=Kepler
endif
ifeq ($(NV_ARCH),Fermi)
  CODE_GEN_CUDA=-gencode arch=compute_20,code=sm_21
else
ifeq ($(NV_ARCH),Kepler)
  CODE_GEN_CUDA=-gencode arch=compute_35,code=sm_35
endif
endif

NVCCFLAGS       := $(NVCCFLAGS) -O3 $(CODE_GEN_CUDA) -m64 -Xptxas -dlcm=ca -Xptxas=-v -use_fast_math #-g -G -O0

#
# partitioning software for MPI versions
#
PARMETIS_VER=4
ifeq ($(PARMETIS_VER),4)
  PARMETIS_INC = -I$(PARMETIS_INSTALL_PATH)/include -DHAVE_PARMETIS -DPARMETIS_VER_4
  PARMETIS_LIB = -L$(PARMETIS_INSTALL_PATH)/lib -lparmetis -lmetis
else
  PARMETIS_INC = -I$(PARMETIS_INSTALL_PATH)/ -DHAVE_PARMETIS
  PARMETIS_LIB = -L$(PARMETIS_INSTALL_PATH)/ -lparmetis -lmetis
endif

PTSCOTCH_INC 	= -I$(PTSCOTCH_INSTALL_PATH)/include -DHAVE_PTSCOTCH
PTSCOTCH_LIB 	= -L$(PTSCOTCH_INSTALL_PATH)/lib/ -lptscotch \
                  -L$(PTSCOTCH_INSTALL_PATH)/lib/ -lptscotcherr


#
# master to make all versions
#
ALL_TARGETS: clean jac_seq jac_genseq jac_openmp jac_cuda jac_mpi

ifeq ($(OP2_COMPILER),pgi)
        ALL_TARGETS += jac_openacc
endif
ifeq ($(OP2_COMPILER),intel)
        ALL_TARGETS += jac_vec
endif


all: $(ALL_TARGETS)


#
# simple sequential version
#

jac_seq:	jac.cpp res.h update.h
		$(CPP) $(CPPFLAGS) jac.cpp $(OP2_INC) $(OP2_LIB) -lop2_seq -o jac_seq

#
# code generated sequential x86 version using kernel files generated by op2.py
#

jac_genseq:     jac_op.cpp update.h res.h jac_seqkernels.cpp res_seqkernel.cpp \
                update_seqkernel.cpp Makefile
	        $(CPP) $(CPPFLAGS) jac_op.cpp jac_seqkernels.cpp \
        	$(OP2_INC) $(OP2_LIB) -lop2_seq -o jac_genseq

#
# code generated x86 vectorized version using kernel files generated by op2.py
#

jac_vec:     jac_op.cpp update.h res.h jac_veckernels.cpp res_veckernel.cpp \
             update_veckernel.cpp Makefile
		$(CPP) $(CPPFLAGS) jac_op.cpp jac_veckernels.cpp \
                $(OP2_INC) $(OP2_LIB) -lop2_seq -o jac_vec


#
# x86 version using kernel files generated by op2.py
#

jac_openmp:	jac_op.cpp update.h res.h jac_kernels.cpp res_kernel.cpp \
		update_kernel.cpp Makefile
		$(CPP) $(CPPFLAGS) $(OMPFLAGS) jac_op.cpp jac_kernels.cpp \
		$(OP2_INC) $(OP2_LIB) -lop2_openmp -o jac_openmp


#
# CUDA version using kernel files generated by op2.py
#

jac_cuda:	jac_op.cpp jac_kernels_cu.o Makefile
		$(CPP) $(CPPFLAGS) $(INC_CUDA) $(OP2_INC) $(OP2_LIB) $(CUDA_LIB) \
		jac_op.cpp jac_kernels_cu.o -lcudart -lop2_cuda -o jac_cuda

jac_kernels_cu.o:	jac_kernels.cu  res_kernel.cu res.h \
			update_kernel.cu  update.h  \
			Makefile
			nvcc $(INC) $(NVCCFLAGS) $(OP2_INC) -c -o jac_kernels_cu.o jac_kernels.cu

#
# OpenACC version
#
jac_openacc:	jac_op.cpp jac_acckernels.c Makefile
		$(CC) $(ACCFLAGS) $(CPPFLAGS) $(OP2_INC) $(OP2_LIB) $(CUDA_LIB) jac_acckernels.c -c
		$(CPP) $(ACCFLAGS) $(CPPFLAGS) $(OP2_INC) $(OP2_LIB) $(CUDA_LIB) \
		jac_op.cpp jac_acckernels.o -lcudart -lop2_cuda -o jac_openacc

#
# mpi with sequential-nodes version
#

jac_mpi:	jac_mpi.cpp update.h res.h Makefile
		$(MPICPP) $(MPIFLAGS) jac_mpi.cpp \
		$(OP2_INC) $(PARMETIS_INC) $(PTSCOTCH_INC) \
		$(OP2_LIB) -lop2_mpi $(PARMETIS_LIB) $(PTSCOTCH_LIB)  -o jac_mpi



#
# cleanup
#

clean:
		rm -f jac_seq jav_vec jac_genseq jac_openmp jac_mpi jac_cuda *.o
