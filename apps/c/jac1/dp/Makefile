#
# The following environment variables should be predefined:
#
# OP2_COMPILER (gnu,intel,etc)
#
# ... and optionally the following. If not defined, then 
# they must be locatable via PATH variables:
#
# OP2_INSTALL_PATH
# CUDA_INSTALL_PATH
# PARMETIS_INSTALL_PATH
# PTSCOTCH_INSTALL_PATH
#

include ../../../make-common.inc

#
# Configure compilers:
#
ifeq ($(OP2_COMPILER),gnu)
  CPP		= g++
  CPPFLAGS	= -g -fPIC -DUNIX -Wall
#  CPPFLAGS	= -O3 -fPIC -DUNIX -Wall -Wextra
  OMPFLAGS	= -fopenmp
  MPICPP	= $(MPICXX_PATH)
  MPIFLAGS	= $(CCFLAGS)
  HIPCC		= hipcc
else
ifeq ($(OP2_COMPILER),intel)
  CPP		= icpc
  CCFLAGS	= -O2 -vec-report -xHost -DMPICH_IGNORE_CXX_SEEK -restrict -fno-alias -inline-forceinline -qopt-report -parallel -DVECTORIZE  #-DCOMM_PERF #-DDEBUG
  CPPFLAGS	= $(CCFLAGS)
  OMPFLAGS	= -qopenmp
  MPICPP	= $(MPICXX_PATH)
  # NVCCFLAGS	= -ccbin=$(MPICPP)
  MPIFLAGS	= $(CCFLAGS)
else
ifeq ($(OP2_COMPILER),pgi)
  CPP           = pgc++
  CC           = pgcc
  CCFLAGS       = -O3
  CPPFLAGS      = $(CCFLAGS)
  OMPFLAGS      = -mp
  MPICC         = $(MPICC_PATH)
  MPICPP        = $(MPICXX_PATH)
  MPIFLAGS      = $(CPPFLAGS)
  NVCCFLAGS     = -ccbin=$(MPICPP)
  ACCFLAGS      = -acc -Minfo=acc -ta=tesla:cc35 -DOPENACC
else
print:
	@echo "unrecognised value for OP2_COMPILER"
endif
endif
endif

#
# set flags for NVCC compilation and linking
#
ifndef NV_ARCH
  MESSAGE=select an NVIDA device to compile in CUDA, e.g. make NV_ARCH=KEPLER
  NV_ARCH=Kepler
endif
ifeq ($(NV_ARCH),Fermi)
  CODE_GEN_CUDA=-gencode arch=compute_20,code=sm_21
else
ifeq ($(NV_ARCH),Kepler)
  CODE_GEN_CUDA=-gencode arch=compute_35,code=sm_35
else
ifeq ($(NV_ARCH),Maxwell)
  CODE_GEN_CUDA=-gencode arch=compute_50,code=sm_50
else
ifeq ($(NV_ARCH),Pascal)
  CODE_GEN_CUDA=-gencode arch=compute_60,code=sm_60
else
ifeq ($(NV_ARCH),Volta)
  CODE_GEN_CUDA=-gencode arch=compute_70,code=sm_70
endif
endif
endif
endif
endif


NVCCFLAGS += -O3 $(CODE_GEN_CUDA) -m64 -Xptxas -dlcm=ca -Xptxas=-v -use_fast_math #-g -G -O0



#
# master to make all versions
#
ALL_TARGETS: clean jac_seq jac_genseq jac_openmp jac_cuda jac_mpi

ifeq ($(OP2_COMPILER),pgi)
        ALL_TARGETS += jac_openacc
endif
ifeq ($(OP2_COMPILER),intel)
        ALL_TARGETS += jac_vec
endif


all: $(ALL_TARGETS)


#
# simple sequential version
#

jac_seq:	jac.cpp res.h update.h
		$(CPP) $(CPPFLAGS) jac.cpp $(OP2_INC) $(OP2_LIB) -lop2_seq -o jac_seq

#
# code generated sequential x86 version using kernel files generated by op2.py
#

jac_genseq:     jac_op.cpp update.h res.h seq/jac_seqkernels.cpp seq/res_seqkernel.cpp \
                seq/update_seqkernel.cpp Makefile
	        $(CPP) $(CPPFLAGS) jac_op.cpp seq/jac_seqkernels.cpp -Iseq -I. \
        	$(OP2_INC) $(OP2_LIB) -lop2_seq -o jac_genseq

#
# code generated x86 vectorized version using kernel files generated by op2.py
#

jac_vec:     jac_op.cpp update.h res.h vec/jac_veckernels.cpp vec/res_veckernel.cpp \
             vec/update_veckernel.cpp Makefile
		$(CPP) $(CPPFLAGS) $(OMPFLAGS) jac_op.cpp vec/jac_veckernels.cpp -Ivec -I. \
                $(OP2_INC) $(OP2_LIB) -lop2_seq -o jac_vec


#
# x86 version using kernel files generated by op2.py
#

jac_openmp:	jac_op.cpp update.h res.h openmp/jac_kernels.cpp openmp/res_kernel.cpp \
		openmp/update_kernel.cpp Makefile
		$(CPP) $(CPPFLAGS) $(OMPFLAGS) jac_op.cpp openmp/jac_kernels.cpp -Iopenmp -I. \
		$(OP2_INC) $(OP2_LIB) -lop2_openmp -o jac_openmp


#
# CUDA version using kernel files generated by op2.py
#

jac_cuda:	jac_op.cpp cuda/jac_kernels_cu.o Makefile
		$(CPP) $(CPPFLAGS) $(INC_CUDA) $(OP2_INC) $(OP2_LIB) $(CUDA_LIB) \
		jac_op.cpp cuda/jac_kernels_cu.o -lcudart -lop2_cuda -o jac_cuda

cuda/jac_kernels_cu.o:	cuda/jac_kernels.cu  cuda/res_kernel.cu res.h \
			cuda/update_kernel.cu  update.h  \
			Makefile
			nvcc $(INC) $(NVCCFLAGS) $(OP2_INC) -Icuda -I. -c -o cuda/jac_kernels_cu.o cuda/jac_kernels.cu

jac_hip:	jac_op.cpp hip/jac_kernels.cpp Makefile
		$(HIPCC) $(CPPFLAGS) $(OP2_INC) $(OP2_LIB) $(CUDA_LIB) \
		jac_op.cpp hip/jac_kernels.cpp -lop2_hip -o jac_hip
#
# OpenACC version
#
jac_openacc:	jac_op.cpp openacc/jac_acckernels.c Makefile
		$(CC) $(ACCFLAGS) $(CPPFLAGS) $(OP2_INC) $(OP2_LIB) $(CUDA_LIB) openacc/jac_acckernels.c -Iopenacc -I. -c -o openacc/jac_acckernels.o
		$(CPP) $(ACCFLAGS) $(CPPFLAGS) $(OP2_INC) $(OP2_LIB) $(CUDA_LIB) \
		jac_op.cpp openacc/jac_acckernels.o -lcudart -lop2_cuda -o jac_openacc

#
# mpi with sequential-nodes version
#

jac_mpi:	jac_mpi.cpp update.h res.h Makefile
		$(MPICPP) $(MPIFLAGS) jac_mpi.cpp \
		$(OP2_INC) $(PARMETIS_INC) $(PTSCOTCH_INC) \
		$(OP2_LIB) -lop2_mpi $(PARMETIS_LIB) $(PTSCOTCH_LIB)  -o jac_mpi



#
# cleanup
#

clean:
		rm -f jac_seq jav_vec jac_genseq jac_openmp jac_mpi jac_cuda *.o
