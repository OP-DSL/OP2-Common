#
# set paths for header files and libraries
#
C_OP2	= $(OP2)/c

INC_OP2 = $(C_OP2)/include
SRC_OP2 = $(C_OP2)/src
LIB_OP2 = $(C_OP2)/lib


#CUDA stuff
CUDA := $(CUDA_INSTALL_PATH)
INC_CUDA := -I$(CUDA)/include -I$(C_OP2) -I.
LIB_CUDA := -L$(CUDA)/lib64


# compiler
CC = icc#gcc
CPP = icpc#g++
MPI_HOME = /home/gihan/openmpi#this should be set as an environment variable
MPICPP = $(MPI_HOME)/bin/mpiCC 

CCFLAGS	:= -O2 -ipo -vec-report -xSSE2,SSE3,SSE4.1,SSE4.2 -g #-DCOMM_PERF #-DDEBUG

#openmp
OMP	:= -openmp -openmp-report2

#
# set flags for compilation and linking
#

# -Xptxas -dlcm=ca   => use L1 cache
# -Xptxas -dlcm=cg   => no L1 cache

#CCFLAGS	:= -g -fPIC -DUNIX -Wall -Wextra
#NVCCFLAGS	:= -g -G -arch=sm_20 -Xptxas=-v -use_fast_math

#CCFLAGS		:= -g
#CCFLAGS		:= -O3 -DUNIX -Wall -Wextra
#NVCCFLAGS	:= -O3 -maxrregcount 48 -arch=sm_20 \
#		   -Xptxas -dlcm=cg -Xptxas=-v -use_fast_math
NVCCFLAGS	:= -O3 -arch=sm_20 \
		   -Xptxas -dlcm=ca -Xptxas=-v -use_fast_math

LIBS		:= $(LIB) -lcudart
PARMETISLIB 	:= $(PARMETIS_INSTALL_PATH)/libparmetis.a $(PARMETIS_INSTALL_PATH)/libmetis.a

C_OP2_H		:= $(C_OP2)/op_seq.h $(C_OP2)/op_lib.h $(C_OP2)/op_lib_core.h
OP2_LIB		:= $(C_OP2)/op_lib.a

EXEC_SEQ = jac_seq
EXEC_OPENMP = jac_openmp
EXEC_CUDA = jac_cuda
EXEC_MPI = jac_mpi

#
# master to make all versions
#

all: jac_seq jac_openmp jac_cuda jac_mpi


#
# simple sequential version
#

jac_seq: jac.cpp res.h update.h $(LIB_OP2)/libop2_seq.a $(INC_OP2)/op_lib_c.h $(INC_OP2)/op_lib_cpp.h
		$(CPP) jac.cpp -I$(INC_OP2) -L$(LIB_OP2) -lop2_seq -o $(EXEC_SEQ)

#
# x86 version using kernel files generated by op2.m
#

jac_openmp:	jac_op.cpp update.h res.h jac_kernels.cpp res_kernel.cpp update_kernel.cpp \
		Makefile $(LIB_OP2)/libop2_openmp.a \
		$(INC_OP2)/op_lib_cpp.h $(INC_OP2)/op_rt_support.h
		$(CC) jac_op.cpp jac_kernels.cpp -O3 $(OMP) -I$(INC_OP2) -L$(LIB_OP2) -lop2_openmp -o $(EXEC_OPENMP) 


#
# CUDA version using kernel files generated by op2.m
#

jac_cuda:	jac_op.cpp jac_kernels_cu.o Makefile $(LIB_OP2)/libop2_cuda.a
		$(CC) -O3 -fPIC $(INC_CUDA) -I$(INC_OP2) -L$(LIB_OP2) $(LIB_CUDA) jac_op.cpp jac_kernels_cu.o -lcudart -lop2_cuda -o $(EXEC_CUDA)

jac_kernels_cu.o:	jac_kernels.cu  \
		res_kernel.cu res.h \
		update_kernel.cu  update.h  \
                Makefile
		nvcc $(INC) $(NVCCFLAGS)  -I$(INC_OP2) 	-c -o jac_kernels_cu.o jac_kernels.cu
	
#
# mpi with sequential-nodes version
#

jac_mpi:	jac_mpi.cpp update.h res.h \
		Makefile $(LIB_OP2)/libop2_mpi.a $(INC_OP2)/op_lib_c.h $(INC_OP2)/op_lib_cpp.h
		$(MPICPP) $(CCFLAGS) jac_mpi.cpp -I$(INC_OP2) -I$(PARMETIS_INSTALL_PATH) -L$(LIB_OP2) -lop2_mpi $(PARMETISLIB) -o $(EXEC_MPI)

		
#
# cleanup
#

clean:
		rm -f $(EXEC_SEQ) $(EXEC_OPENMP) $(EXEC_CUDA) $(EXEC_MPI) *.o
