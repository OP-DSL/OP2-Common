#
# set paths for header files and libraries
#

OP2		:= ../common
CUDA		:= $(CUDA_INSTALL_PATH)
INC		:= -I$(CUDA)/include -I$(OP2) -I.
LIB		:= -L$(CUDA)/lib64

#
# set flags for compilation and linking
#

#CCFLAGS		:= -g -fPIC -DUNIX -Wall -Wextra
CCFLAGS		:= -g -fPIC -DUNIX
NVCCFLAGS	:= -g -G -arch=sm_20 -Xptxas=-v -use_fast_math
LIBS		:= $(LIB) -lcudart
OMP		:= -fopenmp -lgomp
OP2_H		:= $(OP2)/op_seq.h $(OP2)/op_lib.h $(OP2)/op_lib_core.h
OP2_LIB		:= $(OP2)/op_lib.a

#
# master to make all versions
#

all:		jac_seq jac_op jac_cuda

#
# OP2 library
#

$(OP2_LIB):	$(OP2_H) $(OP2)/op_lib_core.c $(OP2)/op_lib.cpp
		cd $(OP2); make

#
# simple sequential version
#

jac_seq:	jac.cpp res.h update.h Makefile $(OP2_H) $(OP2_LIB)
		g++ $(INC) $(CCFLAGS) -o jac_seq jac.cpp $(OP2_LIB)

#
# x86 version using kernel files generated by op2.m
#

jac_op:		jac_op.cpp      res.h          update.h          \
		jac_kernels.cpp res_kernel.cpp update_kernel.cpp \
		Makefile $(OP2_H) $(OP2_LIB)
		g++ $(INC)  $(CCFLAGS) $(OMP) -o jac_op \
				jac_op.cpp jac_kernels.cpp $(OP2_LIB)

#
# CUDA version using kernel files generated by op2.m
#

jac_cuda:	jac_op.cpp jac_kernels_cu.o Makefile $(OP2_LIB)
		g++ $(INC) -fPIC -o jac_cuda jac_op.cpp jac_kernels_cu.o \
				$(OP2_LIB) $(LIBS)

jac_kernels_cu.o:	       res.h         update.h         \
                jac_kernels.cu res_kernel.cu update_kernel.cu \
		Makefile $(OP2_H) $(OP2)/op_lib.cu
		nvcc $(INC) $(NVCCFLAGS) -c -o jac_kernels_cu.o jac_kernels.cu

#
# cleanup
#

clean:
		rm -f jac_seq jac_op jac_cuda *.o
