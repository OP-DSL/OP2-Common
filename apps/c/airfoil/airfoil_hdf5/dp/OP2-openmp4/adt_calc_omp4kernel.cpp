//
// auto-generated by op2.py
//

#pragma omp declare target
inline void adt_calc( const double *x1, const double *x2, const double *x3,
                     const double *x4, const double *q, double *adt) {
  double dx, dy, ri, u, v, c;

  ri = 1.0f / q[0];
  u = ri * q[1];
  v = ri * q[2];
  c = sqrt(gam_ompkernel * gm1_ompkernel * (ri * q[3] - 0.5f * (u * u + v * v)));

  dx = x2[0] - x1[0];
  dy = x2[1] - x1[1];
  *adt = fabs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy);

  dx = x3[0] - x2[0];
  dy = x3[1] - x2[1];
  *adt += fabs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy);

  dx = x4[0] - x3[0];
  dy = x4[1] - x3[1];
  *adt += fabs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy);

  dx = x1[0] - x4[0];
  dy = x1[1] - x4[1];
  *adt += fabs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy);

  *adt = (*adt) * (1.0f / cfl_ompkernel);
}
#pragma omp end declare target

void adt_calc_omp4_kernel(
  int *map0,
  double *data4,
  double *data5,
  double *data0,
  int *col_reord,
  int set_size1,
  int start,
  int end){
  #pragma omp target teams map(to:col_reord,map0,data4,data5,data0)
  #pragma omp distribute parallel for schedule(static,1)
  for ( int e=start; e<end; e++ ){
    int n = col_reord[e];
    int map0idx = map0[n + set_size1 * 0];
    int map1idx = map0[n + set_size1 * 1];
    int map2idx = map0[n + set_size1 * 2];
    int map3idx = map0[n + set_size1 * 3];

    /*
    adt_calc(
      &data0[2 * map0idx],
      &data0[2 * map1idx],
      &data0[2 * map2idx],
      &data0[2 * map3idx],
      &data4[4 * n],
      &data5[1 * n]);
    */
    //variable mapping
    /*
    const double *x1 = &data0[2 * map0idx];
    const double *x2 = &data0[2 * map1idx];
    const double *x3 = &data0[2 * map2idx];
    const double *x4 = &data0[2 * map3idx];
    const double *q = &data4[4*n];
    double *adt = &data5[1*n];
    */
    //inline function
      
    double dx, dy, ri, u, v, c;
  
    ri = 1.0f / data4[4*n + 0];
    u = ri * data4[4*n + 1];
    v = ri * data4[4*n + 2];
    c = sqrt(gam_ompkernel * gm1_ompkernel * (ri * data4[4*n + 3] - 0.5f * (u * u + v * v)));
  
    dx = data0[2 * map1idx + 0] - data0[2 * map0idx + 0];
    dy = data0[2 * map1idx + 1] - data0[2 * map0idx + 1];
    data5[1*n + 0] = fabs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy);
  
    dx = data0[2 * map2idx + 0] - data0[2 * map1idx + 0];
    dy = data0[2 * map2idx + 1] - data0[2 * map1idx + 1];
    data5[1*n + 0] += fabs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy);
  
    dx = data0[2 * map3idx + 0] - data0[2 * map2idx + 0];
    dy = data0[2 * map3idx + 1] - data0[2 * map2idx + 1];
    data5[1*n + 0] += fabs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy);
  
    dx = data0[2 * map0idx + 0] - data0[2 * map3idx + 0];
    dy = data0[2 * map0idx + 1] - data0[2 * map3idx + 1];
    data5[1*n + 0] += fabs(u * dy - v * dx) + c * sqrt(dx * dx + dy * dy);
  
    data5[1*n + 0] = (data5[1*n + 0]) * (1.0f / cfl_ompkernel);
    //end inline func
  }

}
