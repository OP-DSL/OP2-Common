//
// auto-generated by op2.py
//

//user function
#include "../res_calc.h"

// host stub function
void op_par_loop_res_calc(char const *name, op_set set,
  op_arg arg0,
  op_arg arg1,
  op_arg arg2,
  op_arg arg3,
  op_arg arg4,
  op_arg arg5,
  op_arg arg6,
  op_arg arg7){

  int nargs = 8;
  op_arg args[8];

  args[0] = arg0;
  args[1] = arg1;
  args[2] = arg2;
  args[3] = arg3;
  args[4] = arg4;
  args[5] = arg5;
  args[6] = arg6;
  args[7] = arg7;

  // initialise timers
  double cpu_t1, cpu_t2, wall_t1, wall_t2;
  op_timing_realloc(2);
  op_timers_core(&cpu_t1, &wall_t1);

  if (OP_diags>2) {
    printf(" kernel routine with indirection: res_calc\n");
  }

  int set_size = op_mpi_halo_exchanges(set, nargs, args);

  if (set_size > 0) {

    op_map old_mapping = arg6.map; //TODO works only with arg6...
    int set_from_size = op_get_size(old_mapping->from);  
    int set_to_size = op_get_size(old_mapping->to);  
    int old_map_dim = old_mapping->dim;
    int new_map_max_dim=20;  //TODO dimension size???
    double *tmp_incs = (double *)malloc(set_from_size * old_map_dim * arg6.dat->size );//arg6.dat.size = arg6->dim*sizeof(double)
    int *row_lens = (int *)malloc(set_to_size * sizeof(int));
    int *new_map = (int *)malloc(set_to_size * new_map_max_dim * sizeof(int));
    for (int i=0; i<set_to_size ; i++ ) {
      row_lens[i] = 0;
    }
	
	for (int i=0; i<set_from_size * old_map_dim * arg6.dim; i++){
	  tmp_incs[i]=0;
	}
	
//    int size_of_new_map = 0;
    
    for ( int i=0; i<set_from_size; i++ ) {
      for ( int j=0; j<old_map_dim; j++ ) {
	    new_map[old_mapping->map[i*old_map_dim+j] * new_map_max_dim + row_lens[old_mapping->map[i*old_map_dim+j]]] = i * old_map_dim + j;
        row_lens[old_mapping->map[i*old_map_dim+j]]++;
//        size_of_new_map++;
      }      
    }
  
    for ( int n=0; n<set_size; n++ ){

      if (n==set->core_size) {
        op_mpi_wait_all(nargs, args);
      }
      int map0idx;
      int map1idx;
      int map2idx;
      int map3idx;
      map0idx = arg0.map_data[n * arg0.map->dim + 0];
      map1idx = arg0.map_data[n * arg0.map->dim + 1];
      map2idx = arg2.map_data[n * arg2.map->dim + 0];
      map3idx = arg2.map_data[n * arg2.map->dim + 1];

//      res_calc(
//        &((double*)arg0.data)[2 * map0idx],
//        &((double*)arg0.data)[2 * map1idx],
//        &((double*)arg2.data)[4 * map2idx],
//        &((double*)arg2.data)[4 * map3idx],
//        &((double*)arg4.data)[1 * map2idx],
//        &((double*)arg4.data)[1 * map3idx],
//        &((double*)arg6.data)[4 * map2idx],
//        &((double*)arg6.data)[4 * map3idx]);

        res_calc(
          &((double*)arg0.data)[2 * map0idx],
          &((double*)arg0.data)[2 * map1idx],
          &((double*)arg2.data)[4 * map2idx],
          &((double*)arg2.data)[4 * map3idx],
          &((double*)arg4.data)[1 * map2idx],
          &((double*)arg4.data)[1 * map3idx],
          &tmp_incs[(n*old_map_dim+0)*4],
          &tmp_incs[(n*old_map_dim+1)*4]);
    }
	
	for ( int n=0; n<set_to_size; n++ ){
		for ( int i=0; i<row_lens[n]; i++){
		
			((double*)arg6.data)[4 * n + 0] += tmp_incs[new_map[n*new_map_max_dim+i] * 4 + 0];
			((double*)arg6.data)[4 * n + 1] += tmp_incs[new_map[n*new_map_max_dim+i] * 4 + 1];
			((double*)arg6.data)[4 * n + 2] += tmp_incs[new_map[n*new_map_max_dim+i] * 4 + 2];
			((double*)arg6.data)[4 * n + 3] += tmp_incs[new_map[n*new_map_max_dim+i] * 4 + 3];
		}
	}
free(tmp_incs);	
free(row_lens);	
free(new_map);	

  }

  if (set_size == 0 || set_size == set->core_size) {
    op_mpi_wait_all(nargs, args);
  }
  // combine reduction data
  op_mpi_set_dirtybit(nargs, args);

  // update kernel record
  op_timers_core(&cpu_t2, &wall_t2);
  OP_kernels[2].name      = name;
  OP_kernels[2].count    += 1;
  OP_kernels[2].time     += wall_t2 - wall_t1;
  OP_kernels[2].transfer += (float)set->size * arg0.size;
  OP_kernels[2].transfer += (float)set->size * arg2.size;
  OP_kernels[2].transfer += (float)set->size * arg4.size;
  OP_kernels[2].transfer += (float)set->size * arg6.size * 2.0f;
  OP_kernels[2].transfer += (float)set->size * arg0.map->dim * 4.0f;
  OP_kernels[2].transfer += (float)set->size * arg2.map->dim * 4.0f;
}
