#
# The following environment variables should be predefined:
#
# CUDA_INSTALL_PATH
# PARMETIS_INSTALL_PATH
# PTSCOTCH_INSTALL_PATH
# HDF5_INSTALL_PATH
#
# OP2_INSTALL_PATH
# OP2_COMPILER (gnu,intel,etc)
#

#
# set paths for header files and libraries
#
OP2_INC		= -I$(OP2_INSTALL_PATH)/c/include
OP2_LIB		= -L$(OP2_INSTALL_PATH)/c/lib

CUDA_INC	= -I$(CUDA_INSTALL_PATH)/include
CUDA_LIB	= -L$(CUDA_INSTALL_PATH)/lib64


ifeq ($(OP2_COMPILER),gnu)
  CPP		= g++
  CPPFLAGS	= -g -fPIC -DUNIX -Wall #-Wextra
  OMPFLAGS	= -fopenmp
  MPICPP	= /usr/bin/mpiCC
  MPIFLAGS	= $(CCFLAGS)
else
ifeq ($(OP2_COMPILER),intel)
  CPP		= icpc
  CCFLAGS	= -O3 -xAVX -DMPICH_IGNORE_CXX_SEEK -restrict -fno-alias -inline-forceinline -qopt-report -parallel #-DVECTORIZE #-parallel #-DCOMM_PERF #-DDEBUG #-vec-report
  CPPFLAGS 	= $(CCFLAGS)
  OMPFLAGS	= -openmp -openmp-report2
  MPICPP	= $(MPI_INSTALL_PATH)/bin/mpicxx
  MPIFLAGS	= $(CPPFLAGS)
else
print:
	@echo "unrecognised value for OP2_COMPILER"
endif
endif

#
# set flags for NVCC compilation and linking
#
ifndef NV_ARCH
  MESSAGE=select an NVIDA device to compile in CUDA, e.g. make NV_ARCH=KEPLER
  NV_ARCH=Kepler
endif
ifeq ($(NV_ARCH),Fermi)
  CODE_GEN_CUDA=-gencode arch=compute_20,code=sm_21
else
ifeq ($(NV_ARCH),Kepler)
  CODE_GEN_CUDA=-gencode arch=compute_35,code=sm_35
endif
endif

NVCCFLAGS       = -O3 $(CODE_GEN_CUDA) -m64 -Xptxas -dlcm=ca -Xptxas=-v -use_fast_math #-g -G -O0

#VAR		= -DOP_PART_SIZE_1=512 -DOP_PART_SIZE_2=1024 -DOP_PART_SIZE_3=64
#-DOP_BLOCK_SIZE_0=512 -DOP_BLOCK_SIZE_1=64 -DOP_BLOCK_SIZE_2=64 -DOP_BLOCK_SIZE_3=64 -DOP_BLOCK_SIZE_4=64

#
# partitioning software for MPI versions
#
PARMETIS_VER=4
ifeq ($(PARMETIS_VER),4)
  PARMETIS_INC = -I$(PARMETIS_INSTALL_PATH)/include -DHAVE_PARMETIS -DPARMETIS_VER_4
  PARMETIS_LIB = -L$(PARMETIS_INSTALL_PATH)/lib -lparmetis -lmetis
else
  PARMETIS_INC = -I$(PARMETIS_INSTALL_PATH)/ -DHAVE_PARMETIS
  PARMETIS_LIB = -L$(PARMETIS_INSTALL_PATH)/ -lparmetis -lmetis
endif

PTSCOTCH_INC 	= -I$(PTSCOTCH_INSTALL_PATH)/include -DHAVE_PTSCOTCH
PTSCOTCH_LIB 	= -L$(PTSCOTCH_INSTALL_PATH)/lib/ -lptscotch \
                -L$(PTSCOTCH_INSTALL_PATH)/lib/ -lptscotcherr

#
# master to make all versions
#

all: clean airfoil_seq airfoil_genseq airfoil_openmp airfoil_cuda airfoil_mpi airfoil_mpi_genseq airfoil_mpi_cuda airfoil_mpi_openmp

#
# simple sequential version
#

airfoil_seq: airfoil.cpp save_soln.h adt_calc.h res_calc.h bres_calc.h Makefile
	     $(CPP) $(CPPFLAGS) airfoil.cpp $(OP2_INC) $(OP2_LIB) -lop2_seq -o airfoil_seq


#
# codegenerated saequential version
#

airfoil_genseq: airfoil_op.cpp airfoil_seqkernels.cpp \
                save_soln_seqkernel.cpp  save_soln.h \
                adt_calc_seqkernel.cpp   adt_calc.h  \
                res_calc_seqkernel.cpp   res_calc.h  \
                bres_calc_seqkernel.cpp  bres_calc.h \
                update_seqkernel.cpp     update.h    \
                Makefile
	        $(MPICPP) $(VAR) $(CPPFLAGS) $(OP2_INC) $(OP2_INC) \
                $(PARMETIS_INC) $(PTSCOTCH_INC) \
                airfoil_op.cpp -lm airfoil_seqkernels.cpp $(OP2_LIB) -lop2_seq \
                $(PARMETIS_LIB) $(PTSCOTCH_LIB) -o airfoil_genseq

#
# codegenerated vectorised sequential version
#

airfoil_vec: airfoil_op.cpp airfoil_veckernels.cpp \
                save_soln_veckernel.cpp  save_soln.h \
                adt_calc_veckernel.cpp   adt_calc.h  \
                res_calc_veckernel.cpp   res_calc.h  \
                bres_calc_veckernel.cpp  bres_calc.h \
                update_veckernel.cpp     update.h    \
                Makefile
	        $(MPICPP) -DVECTORIZE $(VAR) $(CPPFLAGS) $(OP2_INC) $(OP2_INC) \
                $(PARMETIS_INC) $(PTSCOTCH_INC) \
                airfoil_op.cpp -lm airfoil_veckernels.cpp $(OP2_LIB) -lop2_seq \
                $(PARMETIS_LIB) $(PTSCOTCH_LIB) -o airfoil_vec

#
# x86 version using kernel files generated by op2.m
#

airfoil_openmp:	airfoil_op.cpp airfoil_kernels.cpp \
		save_soln_kernel.cpp  save_soln.h \
		adt_calc_kernel.cpp   adt_calc.h  \
		res_calc_kernel.cpp   res_calc.h  \
		bres_calc_kernel.cpp  bres_calc.h \
		update_kernel.cpp     update.h    \
                Makefile
		$(CPP) $(VAR) $(CPPFLAGS) $(OMPFLAGS) $(OP2_INC) $(OP2_LIB) \
		airfoil_op.cpp airfoil_kernels.cpp -lm -lop2_openmp -o airfoil_openmp

#
# CUDA version using kernel files generated by op2.m
#

airfoil_cuda:	airfoil_op.cpp airfoil_kernels_cu.o Makefile
		$(CPP) $(VAR) $(CPPFLAGS) $(CUDA_INC) $(OP2_INC) $(OP2_LIB) $(CUDA_LIB) \
		airfoil_op.cpp airfoil_kernels_cu.o -lcudart -lop2_cuda -o airfoil_cuda

airfoil_kernels_cu.o:	airfoil_kernels.cu      \
		save_soln_kernel.cu save_soln.h \
		adt_calc_kernel.cu  adt_calc.h  \
		res_calc_kernel.cu  res_calc.h  \
		bres_calc_kernel.cu bres_calc.h \
		update_kernel.cu    update.h    \
		Makefile
		nvcc $(VAR) $(INC) $(NVCCFLAGS) $(OP2_INC) \
		-c -o airfoil_kernels_cu.o \
		airfoil_kernels.cu

#
# mpi with sequential-nodes version
#

airfoil_mpi: airfoil_mpi.cpp save_soln.h adt_calc.h res_calc.h bres_calc.h Makefile
	$(MPICPP) $(MPIFLAGS) $(OP2_INC) $(PARMETIS_INC) $(PTSCOTCH_INC) \
	$(OP2_LIB) airfoil_mpi.cpp -lop2_mpi $(PARMETIS_LIB) $(PTSCOTCH_LIB) -o airfoil_mpi


#
# mpi code generated seq version using kernel files generated by op2.py
#

airfoil_mpi_genseq: airfoil_mpi_op.cpp airfoil_mpi_seqkernels.cpp \
                save_soln_seqkernel.cpp  save_soln.h \
                adt_calc_seqkernel.cpp   adt_calc.h  \
                res_calc_seqkernel.cpp   res_calc.h  \
                bres_calc_seqkernel.cpp  bres_calc.h \
                update_seqkernel.cpp     update.h    \
                Makefile
		$(MPICPP) $(VAR) $(CPPFLAGS) $(OP2_INC) $(OP2_INC) \
                $(PARMETIS_INC) $(PTSCOTCH_INC) \
                airfoil_mpi_op.cpp -lm airfoil_mpi_seqkernels.cpp $(OP2_LIB) -lop2_mpi \
                $(PARMETIS_LIB) $(PTSCOTCH_LIB) -o airfoil_mpi_genseq

	
#
# mpi vectorized seq version using kernel files generated by op2.py
#

airfoil_mpi_vec: airfoil_mpi_op.cpp airfoil_mpi_veckernels.cpp \
                save_soln_veckernel.cpp  save_soln.h \
                adt_calc_veckernel.cpp   adt_calc.h  \
                res_calc_veckernel.cpp   res_calc.h  \
                bres_calc_veckernel.cpp  bres_calc.h \
                update_veckernel.cpp     update.h    \
                Makefile
	        $(MPICPP) $(VAR) -DVECTORIZE $(CPPFLAGS) $(OP2_INC) $(OP2_INC) \
                $(PARMETIS_INC) $(PTSCOTCH_INC) \
                airfoil_mpi_op.cpp -lm airfoil_mpi_veckernels.cpp $(OP2_LIB) -lop2_mpi \
                $(PARMETIS_LIB) $(PTSCOTCH_LIB) -o airfoil_mpi_vec

#
# mpi with openmp-nodes version
#

airfoil_mpi_openmp: airfoil_mpi_op.cpp airfoil_mpi_kernels.cpp \
		    save_soln_kernel.cpp  save_soln.h \
		    adt_calc_kernel.cpp   adt_calc.h  \
		    res_calc_kernel.cpp   res_calc.h  \
		    bres_calc_kernel.cpp  bres_calc.h \
		    update_kernel.cpp     update.h    \
		    Makefile
		    $(MPICPP) $(MPIFLAGS) $(OMPFLAGS) airfoil_mpi_op.cpp airfoil_kernels.cpp \
		    $(OP2_INC) $(PARMETIS_INC) $(PTSCOTCH_INC) $(HDF5_INC) \
		    $(OP2_LIB) -lop2_mpi $(PARMETIS_LIB) $(PTSCOTCH_LIB) \
		    $(HDF5_LIB) -o airfoil_mpi_openmp
	
#
# mpi with CUDA version
#

airfoil_mpi_cuda:	airfoil_mpi_op.cpp airfoil_kernels_mpi_cu.o Makefile
		  $(MPICPP) $(MPIFLAGS) $(OMPFLAGS) airfoil_mpi_op.cpp airfoil_kernels_mpi_cu.o \
		  $(OP2_INC) $(PARMETIS_INC) $(PTSCOTCH_INC) $(HDF5_INC) \
		  $(OP2_LIB) -lop2_mpi_cuda $(PARMETIS_LIB) $(PTSCOTCH_LIB) \
		  $(HDF5_LIB) $(CUDA_LIB) -lcudart -o airfoil_mpi_cuda

airfoil_kernels_mpi_cu.o:	airfoil_mpi_kernels.cu      \
		  save_soln_kernel.cu  save_soln.h \
		  adt_calc_kernel.cu   adt_calc.h  \
		  res_calc_kernel.cu   res_calc.h  \
		  bres_calc_kernel.cu  bres_calc.h \
		  update_kernel.cu     update.h    \
		  Makefile
		  nvcc  $(INC) $(NVCCFLAGS) $(OP2_INC) -I $(MPI_INSTALL_PATH)/include \
		  -c -o airfoil_kernels_mpi_cu.o airfoil_mpi_kernels.cu
		  

		  
#
# cleanup
#

clean:
		rm -f airfoil_seq airfoil_vec airfoil_openmp airfoil_cuda airfoil_mpi airfoil_mpi_vec \
		airfoil_mpi_cuda airfoil_mpi_openmp airfoil_genseq airfoil_mpi_genseq *.o
