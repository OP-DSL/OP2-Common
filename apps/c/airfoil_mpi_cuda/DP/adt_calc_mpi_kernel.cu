//
// auto-generated by op2.m on 25-Oct-2011 14:51:27
//

// user function

__device__
#include "adt_calc.h"


// CUDA kernel function

__global__ void op_cuda_adt_calc(
  double *ind_arg0, int *ind_arg0_maps,
  short *arg0_maps,
  short *arg1_maps,
  short *arg2_maps,
  short *arg3_maps,
  double *arg4,
  double *arg5,
  int   *ind_arg_sizes,
  int   *ind_arg_offs,
  int    block_offset,
  int   *blkmap,
  int   *offset,
  int   *nelems,
  int   *ncolors,
  int   *colors) {


  __shared__ int   *ind_arg0_map, ind_arg0_size;
  __shared__ double *ind_arg0_s;
  __shared__ int    nelem, offset_b;

  extern __shared__ char shared[];

  if (threadIdx.x==0) {

    // get sizes and shift pointers and direct-mapped data

    int blockId = blkmap[blockIdx.x + block_offset];

    nelem    = nelems[blockId];
    offset_b = offset[blockId];

    ind_arg0_size = ind_arg_sizes[0+blockId*1];

    ind_arg0_map = ind_arg0_maps + ind_arg_offs[0+blockId*1];

    // set shared memory pointers

    int nbytes = 0;
    ind_arg0_s = (double *) &shared[nbytes];
  }

  __syncthreads(); // make sure all of above completed

  // copy indirect datasets into shared memory or zero increment

  for (int n=threadIdx.x; n<ind_arg0_size*2; n+=blockDim.x)
    ind_arg0_s[n] = ind_arg0[n%2+ind_arg0_map[n/2]*2];

  __syncthreads();

  // process set elements

  for (int n=threadIdx.x; n<nelem; n+=blockDim.x) {

      // user-supplied kernel call

      adt_calc( ind_arg0_s+arg0_maps[n+offset_b]*2,
                ind_arg0_s+arg1_maps[n+offset_b]*2,
                ind_arg0_s+arg2_maps[n+offset_b]*2,
                ind_arg0_s+arg3_maps[n+offset_b]*2,
                arg4+(n+offset_b)*4,
                arg5+(n+offset_b)*1 );
  }

}


// host stub function

void op_par_loop_adt_calc(char const *name, op_set set,
  op_arg arg0,
  op_arg arg1,
  op_arg arg2,
  op_arg arg3,
  op_arg arg4,
  op_arg arg5 ){


  int    nargs   = 6;
  op_arg args[6] = {arg0,arg1,arg2,arg3,arg4,arg5};

  int    ninds   = 1;
  int    inds[6] = {0,0,0,0,-1,-1};

  int sent[6] = {0,0,0,0,0,0}; //array to set if halo is exchanged
  if(ninds > 0) //indirect loop
  {
      for(int i = 0; i<nargs; i++)
      {
          if(args[i].argtype == OP_ARG_DAT)
          {
              if (OP_diags==1) reset_halo(args[i]);
              sent[i] = exchange_halo_cuda(args[i]);
              //if(sent[i] == 1)wait_all_cuda(args[i]);
          }
      }
  }

  if (OP_diags>2) {
    printf(" kernel routine with indirection: adt_calc \n");
  }

  int block_offset = 0;
  op_plan *Plan;
  double cpu_t1, cpu_t2, wall_t1, wall_t2;

  // get plan

  #ifdef OP_PART_SIZE_1
    int part_size = OP_PART_SIZE_1;
  #else
    int part_size = OP_part_size;
  #endif

  //get offsets
  int core_len = core_num[set->index];
  int noncore_len = set->size + OP_import_exec_list[set->index]->size - core_len;

  //process core set
  if (core_len>0) {
      if (OP_latency_sets[set->index].core_set == NULL) {
      op_set core_set = ( op_set ) malloc ( sizeof ( op_set_core ) );
      core_set->index = set->index;
      core_set->name = set->name;
      core_set->exec_size = 0;
      core_set->nonexec_size = 0;
      core_set->size = core_len;
      OP_latency_sets[set->index].core_set = core_set;
      }
      Plan = op_plan_get_offset(name,OP_latency_sets[set->index].core_set,0,
          part_size,nargs,args,ninds,inds);

      // initialise timers
      op_timers(&cpu_t1, &wall_t1);

      // execute plan

      block_offset = 0;
      for (int col=0; col < Plan->ncolors; col++) {

          #ifdef OP_BLOCK_SIZE_1
          int nthread = OP_BLOCK_SIZE_1;
          #else
          int nthread = OP_block_size;
          #endif

          int nblocks = Plan->ncolblk[col];
          int nshared = Plan->nshared;
          op_cuda_adt_calc<<<nblocks,nthread,nshared>>>(
        (double *)arg0.data_d, Plan->ind_maps[0],
        Plan->loc_maps[0],
        Plan->loc_maps[1],
        Plan->loc_maps[2],
        Plan->loc_maps[3],
        (double *)arg4.data_d,
        (double *)arg5.data_d,
        Plan->ind_sizes,
        Plan->ind_offs,
        block_offset,
        Plan->blkmap,
        Plan->offset,
        Plan->nelems,
        Plan->nthrcol,
        Plan->thrcol);

    cutilSafeCall(cudaThreadSynchronize());
    cutilCheckMsg("op_cuda_adt_calc execution failed\n");

    block_offset += nblocks;
      }

      op_timers(&cpu_t2, &wall_t2);
      OP_kernels[1].time     += wall_t2 - wall_t1;
  }

  if(ninds > 0) //indirect loop
  {
      for(int i = 0; i<nargs; i++)
      {
          if(args[i].argtype == OP_ARG_DAT)
          {
              if(sent[i] == 1)wait_all_cuda(args[i]);
          }
      }
  }

  op_timers(&cpu_t1, &wall_t1);

  if (noncore_len>0) {
    if(OP_latency_sets[set->index].noncore_set == NULL) {
        op_set noncore_set = ( op_set ) malloc ( sizeof ( op_set_core ) );
        noncore_set->size = noncore_len;
        noncore_set->name = set->name;
        noncore_set->index = set->index;
        noncore_set->exec_size = 0;
        noncore_set->nonexec_size = 0;
        OP_latency_sets[set->index].noncore_set = noncore_set;
    }

    Plan = op_plan_get_offset(name,OP_latency_sets[set->index].noncore_set,
        core_len,part_size,nargs,args,ninds,inds);

    // initialise timers
    op_timers(&cpu_t1, &wall_t1);

    // execute plan
    block_offset = 0;

    for (int col=0; col < Plan->ncolors; col++) {

      /*#ifdef OP_BLOCK_SIZE_1
        int nthread = OP_BLOCK_SIZE_1;
    #else
      int nthread = OP_block_size;
    #endif    */
    int nthread = 128;

      int nblocks = Plan->ncolblk[col];
      int nshared = Plan->nshared;
      op_cuda_adt_calc<<<nblocks,nthread,nshared>>>(
         (double *)arg0.data_d, Plan->ind_maps[0],
         Plan->loc_maps[0],
         Plan->loc_maps[1],
         Plan->loc_maps[2],
         Plan->loc_maps[3],
         (double *)arg4.data_d + core_len*arg4.dim,
         (double *)arg5.data_d + core_len*arg5.dim,
         Plan->ind_sizes,
         Plan->ind_offs,
         block_offset,
         Plan->blkmap,
         Plan->offset,
         Plan->nelems,
         Plan->nthrcol,
         Plan->thrcol);

      cutilSafeCall(cudaThreadSynchronize());
      cutilCheckMsg("op_cuda_adt_calc execution failed\n");

      block_offset += nblocks;
    }
  op_timers(&cpu_t2, &wall_t2);
  OP_kernels[1].time     += wall_t2 - wall_t1;
  }

  //set dirty bit on direct/indirect datasets with access OP_INC,OP_WRITE, OP_RW
  for(int i = 0; i<nargs; i++)
      if(args[i].argtype == OP_ARG_DAT)
        set_dirtybit(args[i]);

  //performe any global operations
  // - NONE

  // update kernel record


  op_timing_realloc(1);
  OP_kernels[1].name      = name;
  OP_kernels[1].count    += 1;
  OP_kernels[1].transfer  += Plan->transfer;
  OP_kernels[1].transfer2 += Plan->transfer2;
}

