module adt_calc_cuda_module

use OP2_C
use cudaConfigurationParams
use OP2Profiling
use cudafor

	type varSizes_adt_calc

		integer(4) :: parg0DatDSize
		integer(4) :: pindMaps1Size
		integer(4) :: pmaps1Size
		integer(4) :: pmaps2Size
		integer(4) :: pmaps3Size
		integer(4) :: pmaps4Size
		integer(4) :: parg4DatDSize
		integer(4) :: parg5DatDSize
		integer(4) :: pindSizesSize
		integer(4) :: pindOffsSize
		integer(4) :: pblkMapSize
		integer(4) :: poffsetSize
		integer(4) :: pnelemsSize
		integer(4) :: pnthrcolSize
		integer(4) :: pthrcolSize

	end type varSizes_adt_calc

  real(8), constant :: adt_calc_gam, &
											 adt_calc_gm1, &
											 adt_calc_cfl, &
											 adt_calc_eps, &
											 adt_calc_mach, &
											 adt_calc_alpha, &
											 adt_calc_air_const, &
											 adt_calc_qinf(4)
	

	! logical that tells if the input data to the kernel has been already generated
	! by previous calls to this same op_par_loop function
	logical :: isKernelInputDataGenerated = .false.


	! input data to kernel and associated variables
!	real(8), dimension(:), allocatable, device :: argument0
!	real(8), dimension(:), allocatable, device :: argument4
!	real(8), dimension(:), allocatable, device :: argument5
	integer(4) :: arg0Size, arg4Size, arg5Size
	type(varSizes_adt_calc), device :: argSizesMod
	
	type(c_ptr) :: planRet


	
!	type(c_ptr) :: planRet
!	type(op_plan), pointer :: actualPlan
!	integer, pointer, dimension(:) :: pnindirect
!	type(c_devptr), pointer, dimension(:) :: pindMaps
!	integer(4), dimension(1) :: pindMapsSize ! dimension = indsNumber (= 1, see below)
!	integer, allocatable, device, dimension(:) :: pindMaps1
!	integer(4) :: pindMaps1Size
!	type(c_devptr), pointer, dimension(:) :: pmaps
!	integer(4), dimension(6) :: pmapsSize ! dimension = argsNumber (= 6, see below)
!	integer(2), allocatable, device, dimension(:) :: pMaps1
!	integer(2), allocatable, device, dimension(:) :: pMaps2
!	integer(2), allocatable, device, dimension(:) :: pMaps3
!	integer(2), allocatable, device, dimension(:) :: pMaps4
!	integer(2), allocatable, device, dimension(:) :: pMaps5 ! not actually used
!	integer(2), allocatable, device, dimension(:) :: pMaps6 ! not actually used
!	integer(4) :: pmaps1Size, pmaps2Size, pmaps3Size, pmaps4Size, pmaps5Size, pmaps6Size
!	real(8), device, allocatable, dimension(:) :: parg4DatD ! real is obtained from op_dat arg type
!	integer(4) :: parg4DatDSize
!	real(8), device, allocatable, dimension(:) :: parg5DatD ! real is obtained from op_dat arg type
!	integer(4) :: parg5DatDSize
!	integer, device, allocatable, dimension(:) :: pindSizes
!	integer(4) :: pindSizesSize
!	integer, device, allocatable, dimension(:) :: pindOffs
!	integer(4) :: pindOffsSize
!	integer, device, allocatable, dimension(:) :: pblkMap
!	integer(4) :: pblkMapSize
!	integer, device, allocatable, dimension(:) :: poffset
!	integer(4) :: poffsetSize
!	integer, device, allocatable, dimension(:) :: pnelems
!	integer(4) :: pnelemsSize
!	integer, device, allocatable, dimension(:) :: pnthrcol
!	integer(4) :: pnthrcolSize
!	integer, device, allocatable, dimension(:) :: pthrcol
!	integer(4) :: pthrcolSize
!	integer, pointer, dimension(:) :: ncolblk		


contains

	attributes(host) subroutine adt_calc_initialiseConstants ()

		implicit none

		real(8) :: p, r, u, e

			adt_calc_gam = 1.400000
			adt_calc_gm1 = 0.400000
			adt_calc_cfl = 0.900000
			adt_calc_eps = 0.050000
			adt_calc_alpha = 0.052360
			
			adt_calc_qinf(1) = 1.000000 ! r
			adt_calc_qinf(2) = 0.473286 ! r * u
			adt_calc_qinf(3) = 0.000000 ! 0.0
			adt_calc_qinf(4) = 2.612000 ! r * e
!
!
!		adt_calc_gam = 1.4
!		adt_calc_gm1 = 1.4 - 1.0 ! the first operand was a reference to the gam variable...not accepted by Fortran CUDA
!		adt_calc_cfl = 0.9
!		adt_calc_eps = 0.05
!
!		adt_calc_mach  = 0.4
!		adt_calc_alpha = 3.0 * atan(1.0) / 45.0
!		p     = 1.0
!		r     = 1.0
!		u     = sqrt ( adt_calc_gam * p / r ) * adt_calc_mach
!		e     = p / ( r * adt_calc_gm1 ) + 0.5 * u * u
!
!		adt_calc_qinf(1) = r
!		adt_calc_qinf(2) = r * u
!		adt_calc_qinf(3) = 0.0
!		adt_calc_qinf(4) = r * e
!	
	end subroutine adt_calc_initialiseConstants

	attributes(device) subroutine adt_calc ( x1, x2, x3, x4, q, adt )

		implicit none

		! formal parameters
		real(8), shared, dimension(2) :: x1
		real(8), shared, dimension(2) :: x2
		real(8), shared, dimension(2) :: x3
		real(8), shared, dimension(2) :: x4
		real(8), dimension(4) :: q
		real(8), dimension(1) :: adt

		! local variables
		real(8) :: dx, dy, ri, u, v, c
		
		! computation
		ri = 1.0 / q(1)
		u = ri * q(2)
		v = ri * q(3)
		c = sqrt ( adt_calc_gam * adt_calc_gm1 * ( ri * q(4) - 0.5 * ( u*u + v*v ) ) )

		dx = x2(1) - x1(1)
		dy = x2(2) - x1(2)
		adt(1) = abs ( u * dy - v * dx ) + c * sqrt ( dx*dx + dy*dy )
		
		dx = x3(1) - x2(1)
		dy = x3(2) - x2(2)
		adt(1) = adt(1) + abs ( u * dy - v * dx ) + c * sqrt ( dx*dx + dy*dy )


		dx = x4(1) - x3(1)
		dy = x4(2) - x3(2)
		adt(1) = adt(1) + abs ( u * dy - v * dx ) + c * sqrt ( dx*dx + dy*dy )

		dx = x1(1) - x4(1)
		dy = x1(2) - x4(2)
		adt(1) = adt(1) + abs ( u * dy - v * dx ) + c * sqrt ( dx*dx + dy*dy )

		adt(1) = adt(1) / adt_calc_cfl

	end subroutine adt_calc


	attributes(global) subroutine op_cuda_adt_calc ( argSizes, &
																								 & parg0DatD, &
																								 & pindMaps1, &
																								 & pmaps1, &
																								 & pmaps2, &
																								 & pmaps3, &
																								 & pmaps4, &
																								 & parg4DatD, &
																								 & parg5DatD, &
																								 & pindSizes, &
																								 & pindOffs, &
																								 & blockOffset, &
																								 & pblkMap, &
																								 & poffset, &
																								 & pnelems, &
																								 & pnthrcol, &
																								 & pthrcol &
																							 & )

		implicit none
		intrinsic mod
		
		type(varSizes_adt_calc), device :: argSizes
		
		! formal parameters
		! first declare sizes
											 
		real(8), device, dimension(0:(argSizes%parg0DatDSize-1)) :: parg0DatD
		
		integer, device, dimension(0:(argSizes%pindMaps1Size-1)) :: pindMaps1

		integer(2), device, dimension(0:(argSizes%pmaps1Size-1)) :: pmaps1
		integer(2), device, dimension(0:(argSizes%pmaps2Size-1)) :: pmaps2
		integer(2), device, dimension(0:(argSizes%pmaps3Size-1)) :: pmaps3
		integer(2), device, dimension(0:(argSizes%pmaps4Size-1)) :: pmaps4
		
		real(8), device, dimension(0:(argSizes%parg4DatDSize-1)) :: parg4DatD
		real(8), device, dimension(0:(argSizes%parg5DatDSize-1)) :: parg5DatD

		integer(4), device, dimension(0:(argSizes%pindSizesSize-1)) :: pindSizes
		integer(4), device, dimension(0:(argSizes%pindOffsSize-1)) :: pindOffs
		
		integer(4), value :: blockOffset

		integer(4), device, dimension(0:(argSizes%pblkMapSize-1)) :: pblkMap
		integer(4), device, dimension(0:(argSizes%poffsetSize-1)) :: poffset
		integer(4), device, dimension(0:(argSizes%pnelemsSize-1)) :: pnelems
		integer(4), device, dimension(0:(argSizes%pnthrcolSize-1)) :: pnthrcol
		integer(4), device, dimension(0:(argSizes%pthrcolSize-1)) :: pthrcol


		! declaring shared variables
		integer, shared :: ind_arg0_size
		integer, shared :: nelem
		integer, shared :: offset_b
		integer, shared :: blockId

		! the following shared variable is allocated by the kernel call (nshared parameter)
		real(8), shared :: myshared(0:*)		

		integer :: nbytes

		integer :: n, moduled, whileBound
		
		if ( (threadidx%x -1) .eq. 0 ) then 
		
			! get sizes and shift pointers and direct-mapped data

			blockId = pblkmap((blockidx%x-1) + blockOffset )
		
			nelem = pnelems(blockId)
			offset_b = poffset(blockId)
			
			ind_arg0_size = pindSizes(0 + blockId * 1)
			                                                                                  
			! set indices to access shared memory (replaces pointers which are not available in Fortran CUDA shared variables)
			nbytes = 0

			! can't do this because pointers are not allowed in shared memory
			! for now, I will use shared[nbytes] = shared[0] = shared!
			! ind_arg0_s = (float *) &shared[nbytes];
		end if
		
		! make sure all of above completed
		call syncthreads()

		! copy indirect datasets into shared memory or zero increment
		n = (threadidx%x-1)
		whileBound = ind_arg0_size * 2
		do while ( n .lt. whileBound )
			! nbytes = 0 => 0 + ..
			moduled = mod ( n, 2 )
			myshared(0 + n) = parg0DatD(moduled  + (pindMaps1(0+ ( pindOffs(0 + blockId * 1 ) ) + (n / 2))) * 2 )
			
			n = n + (blockdim%x)
		end do									           

		! process set elements
		n = (threadidx%x-1)
    do while ( n < nelem )
			
			call adt_calc ( myshared( 0 + pmaps1(n + offset_b) * 2 : (0 + pmaps1(n + offset_b) * 2) + 2 ), &
										& myshared( 0 + pmaps2(n + offset_b) * 2 : (0 + pmaps2(n + offset_b) * 2) + 2 ), &
										& myshared( 0 + pmaps3(n + offset_b) * 2 : (0 + pmaps3(n + offset_b) * 2) + 2 ), &
										& myshared( 0 + pmaps4(n + offset_b) * 2 : (0 + pmaps4(n + offset_b) * 2) + 2 ), &
										& parg4DatD( (n + offset_b) * 4 : (n + offset_b) * 4 + 4), &
										& parg5DatD( (n + offset_b) * 1 : (n + offset_b) * 1 + 1) &
									&	)
			
			n = n + (blockdim%x)
		end do

	end subroutine op_cuda_adt_calc

	attributes(host) function op_par_loop_adt_calc ( subroutineName, set, &
																									 & arg0,   idx0, map0, access0, &
																									 & arg1,   idx1, map1, access1, &
																									 & arg2,   idx2, map2, access2, &
																									 & arg3,   idx3, map3, access3, &
																									 & arg4,   idx4, map4, access4, &
																									 & arg5,   idx5, map5, access5  &
																								 & )

		! use directives	
		use, intrinsic :: ISO_C_BINDING
		use cudafor

		! mandatory	
		implicit none
		
		type(profInfo) :: op_par_loop_adt_calc
		
		
		! formal arguments
		character(kind=c_char,len=*), intent(in) :: subroutineName
		
		! data set on which we loop
		type(op_set), intent(in) :: set

		! data ids used in the function
		type(op_dat) :: arg0, arg1, arg2, arg3, arg4, arg5
		
		! index to be used in first and second pointers
		integer(4), intent(in) :: idx0, idx1, idx2, idx3, idx4, idx5
		
		! ptr ids for indirect access to data
		type(op_map) :: map0, map1, map2, map3, map4, map5
		
		! access values for arguments
		integer(4), intent(in) :: access0, access1, access2, access3, access4, access5

!		! Compiler: variables used to invoke cplan 
		integer(4) :: args(6), idxs(6), maps(6), accs(6), inds(6)
		integer(4) :: argsNumber, indsNumber

		integer(4) :: iter
		
!		! returned plan address by cplan and plan functions
!		type(c_ptr) :: planRet
!		
!		! variable for storing the actual OP Plan
		type(op_plan), pointer :: actualPlan
			
		! iteration and offset variables to implement plan execution
		integer(4) :: blockOffset, col

		! configuration variables for main kernel call
		integer(4) :: nblocks, nthread, nshared
		
		! iteration variables
		integer(4) :: i, m
		

		! value returned by thread synchronisation function
		integer(4) :: threadSynchRet
		
		
		! Fortran variable for Host variable
		integer, pointer, dimension(:) :: ncolblk
!		
		integer, pointer, dimension(:) :: pnindirect
				
		! ind_maps is an array of device pointers allocated on the host memory
		type(c_devptr), pointer, dimension(:) :: pindMaps
		integer(4), dimension(1) :: pindMapsSize ! dimension = indsNumber (= 1, see below)
!								
!		! as many pindMapsI as the positions of pindMaps (just one for this case)
		integer, allocatable, device, dimension(:) :: pindMaps1
		integer(4) :: pindMaps1Size
!		
!		! maps is an array of device pointers allocated on the host memory
		type(c_devptr), pointer, dimension(:) :: pmaps
		integer(4), dimension(6) :: pmapsSize ! dimension = argsNumber (= 6, see below)
!
!		! as many pMapsI as the positions of pmaps (6 for this case) (they are short integers)
		integer(2), allocatable, device, dimension(:) :: pMaps1
		integer(2), allocatable, device, dimension(:) :: pMaps2
		integer(2), allocatable, device, dimension(:) :: pMaps3
		integer(2), allocatable, device, dimension(:) :: pMaps4
		integer(2), allocatable, device, dimension(:) :: pMaps5 ! not actually used
		integer(2), allocatable, device, dimension(:) :: pMaps6 ! not actually used
!
!		! last two not actually used
		integer(4) :: pmaps1Size, pmaps2Size, pmaps3Size, pmaps4Size, pmaps5Size, pmaps6Size
!
		real(8), device, allocatable, dimension(:) :: parg4DatD ! real is obtained from op_dat arg type
		integer(4) :: parg4DatDSize
!
		real(8), device, allocatable, dimension(:) :: parg5DatD ! real is obtained from op_dat arg type
		integer(4) :: parg5DatDSize
!
		integer, device, allocatable, dimension(:) :: pindSizes
		integer(4) :: pindSizesSize
!		
		integer, device, allocatable, dimension(:) :: pindOffs
		integer(4) :: pindOffsSize
!		
		integer, device, allocatable, dimension(:) :: pblkMap
		integer(4) :: pblkMapSize
!		
		integer, device, allocatable, dimension(:) :: poffset
		integer(4) :: poffsetSize
!		
		integer, device, allocatable, dimension(:) :: pnelems
		integer(4) :: pnelemsSize
!		
		integer, device, allocatable, dimension(:) :: pnthrcol
		integer(4) :: pnthrcolSize
!		
		integer, device, allocatable, dimension(:) :: pthrcol
		integer(4) :: pthrcolSize
		
		! variables for marshalling data from host to device memory and back
		integer(4) :: arg0Size, arg4Size, arg5Size
		real(8), dimension(:), pointer :: c2fPtrArg0
		real(8), dimension(:), pointer :: c2fPtrArg4
		real(8), dimension(:), pointer :: c2fPtrArg5

		real(8), dimension(:), allocatable, device :: argument0
		real(8), dimension(:), allocatable, device :: argument4
		real(8), dimension(:), allocatable, device :: argument5


		! variable storing CUDA kernel argument sizes
!		type(varSizes_adt_calc), device :: argSizes
		
		! profiling
		integer :: istat
		type (cudaEvent) :: startKernelTime, stopKernelTime, startHostTime, stopHostTime
		real(4) :: tmpHostTime

		! create events
		istat = cudaEventCreate(startKernelTime)
		istat = cudaEventCreate(stopKernelTime)
		istat = cudaEventCreate(startHostTime)
		istat = cudaEventCreate(stopHostTime)
		
		istat = cudaEventRecord ( startHostTime, 0 )
		
		if ( isKernelInputDataGenerated .eq. .false. ) then ! generate kernel input data

!			isKernelInputDataGenerated = .true.
		
			! get the plan
			args(1) = arg0%index
			args(2) = arg1%index
			args(3) = arg2%index
			args(4) = arg3%index
			args(5) = arg4%index
			args(6) = arg5%index
		
			idxs(1) = idx0
			idxs(2) = idx1
			idxs(3) = idx2
			idxs(4) = idx3
			idxs(5) = idx4
			idxs(6) = idx5
			
			! when passing from OP2 Fortran to OP2 C++ we have to decrement the idx values (not 1->N, but 0->N-1)
			! except -1 which indicates OP_ID or OP_GBL
			do iter = 1, 6
				if ( idxs(iter) /= -1 ) idxs(iter) = idxs(iter) - 1 
			end do

			maps(1) = map0%index
			maps(2) = map1%index
			maps(3) = map2%index
			maps(4) = map3%index
			maps(5) = map4%index
			maps(6) = map5%index

			accs(1) = access0
			accs(2) = access1
			accs(3) = access2
			accs(4) = access3
			accs(5) = access4
			accs(6) = access5


			! Compiler: generate this information by analysing the arguments
			argsNumber = 6
			indsNumber = 1 ! warning: this means the number of op_dat accessed indirectly, not the number of arguments!!
		
			inds(1) = 0
			inds(2) = 0
			inds(3) = 0
			inds(4) = 0
			inds(5) = -1
			inds(6) = -1

			! get the plan
			planRet = cplan ( subroutineName, set%index, argsNumber, args, idxs, maps, accs, indsNumber, inds )  		


			call adt_calc_initialiseConstants()

		end if

			! stage in of input arguments (transfer pointers + copy from host to device memory)
			
			! 1. transfer C pointers to Fortran pointers
			arg0Size = arg0%dim * arg0%set%size
			call c_f_pointer ( arg0%dat_d, argument0, (/arg0Size/) )
			
			arg4Size = arg4%dim * arg4%set%size
			call c_f_pointer ( arg4%dat_d, argument4, (/arg4Size/) )
			
			arg5Size = arg5%dim * arg5%set%size
			call c_f_pointer ( arg5%dat_d, argument5, (/arg5Size/) )
			
			! convert arguments and plan data to Fortran pointers (not a copy!)
			! Typically, first compute size, then transform pointer
			
			! transform the returned C pointer to a type(op_plan) variable
			call c_f_pointer ( planRet, actualPlan )		
			
			! convert nindirect  used to generate the pindMapsSize array of sizes
			call c_f_pointer ( actualPlan%nindirect, pnindirect, (/indsNumber/) )
				
			! convert pindMaps: there are indsNumber ind_maps
			call c_f_pointer ( actualPlan%ind_maps, pindMaps, (/indsNumber/) )
			
			! convert first position of the pindMaps array (the size is stored in the corresponding pnindirect position)
			call c_f_pointer ( pindMaps(1), pindMaps1, pnindirect(1) )
			! must be done for all indirect pointers: in this case just one op_dat is indirectly accessed)
			
			! convert maps in op_plan: there are argsNumber maps
			call c_f_pointer ( actualPlan%maps, pmaps, (/argsNumber/) )
			
			! convert positions in pmaps (only if the corresponding inds position is >= 0 (see op_support.cpp))
			! can't do a do-loop because I can't generate variable name
			if ( inds(1) .ge. 0 ) then
				pmaps1Size = set%size
				call c_f_pointer ( pmaps(1), pmaps1, (/pmaps1Size/) )
			end if
			
			if ( inds(2) .ge. 0 ) then
				pmaps2Size = set%size
				call c_f_pointer ( pmaps(2), pmaps2, (/pmaps2Size/) )
			end if
			
			if ( inds(3) .ge. 0 ) then
				pmaps3Size = set%size
				call c_f_pointer ( pmaps(3), pmaps3, (/pmaps3Size/) )
			end if
			
			if ( inds(4) .ge. 0 ) then
				pmaps4Size = set%size
				call c_f_pointer ( pmaps(4), pmaps4, (/pmaps4Size/) )
			end if
			
			if ( inds(5) .ge. 0 ) then
				pmaps5Size = set%size
				call c_f_pointer ( pmaps(5), pmaps5, (/pmaps5Size/) )
			end if
			
			if ( inds(6) .ge. 0 ) then
				pmaps6Size = set%size
				call c_f_pointer ( pmaps(6), pmaps6, (/pmaps6Size/) )
			end if	
			
			! convert argument 0 
			!(This will be needed in the final version, when the op_decl_dat copies data to
			! device memory)
			!parg0DatDSize = arg0%dim * arg0%set%size
			!call c_f_pointer ( arg0%dat_d, parg0DatD, (/parg0DatDSize/) )

			! converting ncolblk field to fortran variable
			call c_f_pointer ( actualPlan%ncolblk, ncolblk, (/set%size/) )
				
			! this must be done for all directly accessed arguments
			!(This will be needed in the final version, when the op_decl_dat copies data to
			! device memory)
			!call c_f_pointer ( arg4%dat_d, parg4DatD, (/set%size/) )
			!call c_f_pointer ( arg5%dat_d, parg5DatD, (/set%size/) )
				
			! ind_sizes field has nblocks*indsNumber size
			pindSizesSize = actualPlan%nblocks * indsNumber
			call c_f_pointer ( actualPlan%ind_sizes, pindSizes, (/pindSizesSize/) )
				
			! ind_offset field has the same dimension of ind_sizes
			pindOffsSize = pindSizesSize
			call c_f_pointer ( actualPlan%ind_offs, pindOffs, (/pindOffsSize/) )
				
			! blkmap field has dimension nblocks
			pblkMapSize = actualPlan%nblocks
			call c_f_pointer ( actualPlan%blkmap, pblkMap, (/pblkMapSize/) )
				
			! offset field has dimension nblocks
			poffsetSize = actualPlan%nblocks
			call c_f_pointer ( actualPlan%offset, poffset, (/poffsetSize/) )
			
			! nelems field has dimension nblocks
			pnelemsSize = actualPlan%nblocks
			call c_f_pointer ( actualPlan%nelems, pnelems, (/pnelemsSize/) )

			! nthrcol field has dimension nblocks
			pnthrcolSize = actualPlan%nblocks
			call c_f_pointer ( actualPlan%nthrcol, pnthrcol, (/pnthrcolSize/) )
			
			! thrcol field has dimension set%size
			pthrcolSize = set%size
			call c_f_pointer ( actualPlan%thrcol, pthrcol, (/pthrcolSize/) )

			blockOffset = 0
		

		if ( isKernelInputDataGenerated .eq. .false. ) then ! generate kernel input data

			isKernelInputDataGenerated = .true.

			! set up arg sizes
			argSizesMod%parg0DatDSize = arg0Size
			argSizesMod%pindMaps1Size = pnindirect(1)
			argSizesMod%pmaps1Size = pmaps1Size
			argSizesMod%pmaps2Size = pmaps2Size
			argSizesMod%pmaps3Size = pmaps3Size
			argSizesMod%pmaps4Size = pmaps4Size
			argSizesMod%parg4DatDSize = arg4Size
			argSizesMod%parg5DatDSize = arg5Size
			argSizesMod%pindSizesSize = pindSizesSize
			argSizesMod%pindOffsSize = pindOffsSize
			argSizesMod%pblkMapSize = pblkMapSize
			argSizesMod%poffsetSize = poffsetSize
			argSizesMod%pnelemsSize = pnelemsSize
			argSizesMod%pnthrcolSize = pnthrcolSize
			argSizesMod%pthrcolSize = pthrcolSize


		end if


		istat = cudaEventRecord ( stopHostTime, 0 )
		istat = cudaEventSynchronize ( stopHostTime )
		istat = cudaEventElapsedTime ( tmpHostTime, startHostTime, stopHostTime )

		op_par_loop_adt_calc%hostTime = 0
		op_par_loop_adt_calc%hostTime = op_par_loop_adt_calc%hostTime + tmpHostTime
		tmpHostTime = 0
		
	  istat = cudaEventRecord ( startKernelTime, 0 )
		
		! execute the plan
		do col = 0, (actualPlan%ncolors-1)
			
			nblocks = ncolblk(col+1) !+1 is needed because ncolblk is indexed from 1:set%size and not from 0:set%size-1
			nthread = FOP_BLOCK_SIZE
			nshared = actualPlan%nshared

			! call the main kernel (I need to add the variable sizes, otherwise we would get sigsegv in copy back)
			call op_cuda_adt_calc <<< nblocks, nthread, nshared >>> ( argSizesMod, &
																															& argument0, &
																															& pindMaps1, &
																															& pmaps1, &
																															& pmaps2, &
																															& pmaps3, &
																															& pmaps4,  &
																															& argument4, &
																															& argument5, &
																															& pindSizes, &
																															& pindOffs, &
																															& blockOffset, & 
																															& pblkMap, &
																															& poffset, &
																															& pnelems, &
																															& pnthrcol, &
																															& pthrcol &
																														& )
			
			! wait for the threads on device to terminate execution
			threadSynchRet = cudaThreadSynchronize()
		
			blockOffset = blockOffset + nblocks
		
		end do

		istat = cudaEventRecord (stopKernelTime, 0 )
		istat = cudaEventSynchronize ( stopKernelTime )
		istat = cudaEventElapsedTime ( op_par_loop_adt_calc%kernelTime, startKernelTime, stopKernelTime )

		istat = cudaEventRecord ( startHostTime, 0 )
		istat = cudaEventRecord ( stopHostTime, 0 )
		istat = cudaEventSynchronize ( stopHostTime )
		istat = cudaEventElapsedTime ( tmpHostTime, startHostTime, stopHostTime )

		op_par_loop_adt_calc%hostTime = op_par_loop_adt_calc%hostTime + tmpHostTime


		! 2. copy back device to host
!		c2fPtrArg0 = argument0
!		c2fPtrArg4 = argument4
!		c2fPtrArg5 = argument5
!		
!		! deallocate space on device
!		deallocate ( argument0 )
!		deallocate ( argument4 )
!		deallocate ( argument5 )
				
	end function op_par_loop_adt_calc

end module adt_calc_cuda_module


